<!DOCTYPE html>
<html>

<head>

    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TrackTool</title>
    <script src='./js/dat.gui.min.js'></script>

    <style type='text/css'>

        html, body, div {
            margin: 0;
            padding: 0;
            border: 0;
        }

        body {
            min-height: 100vh;
            overflow: hidden;
            background: radial-gradient(#202020, #000000);
        }

    </style>

    <script>

        document.addEventListener( 'DOMContentLoaded', () => {

            //---

            console.clear();
            console.log( 'Track Tool' );

            //---

            const DEBUG = true;
            let debugElements = [];

            const MATHPI2 = Math.PI * 2;

            const SNAP_TO_DISTANCE = 25;

            const EDITOR_MODE_ENUM = Object.freeze( {
                drawPath: 'drawPath',
                setstartPosition: 'setstartPosition',
                setendPosition: 'setendPosition',
                getPathSegment: 'getPathSegment'
            } );

            let editorMode = EDITOR_MODE_ENUM.drawPath;

            let width = 1024;
            let height = 512;

            const canvas = document.createElement( 'canvas' );
            const context = canvas.getContext( '2d' );

            let animationFrame = null;

            let imageData = null;
            let data = null;

            const border = { left: 1, top: 1, right: width, bottom: height };

            let mouseDown = false;
            let mousePos = { x: 0, y: 0 };
            let mousePosStart = { x: 0, y: 0 };
            let mousePosEnd = { x: 0, y: 0 };
            const mouseCursor = { diameter: 9, color: { r: 255, g: 255, b: 255, a: 255 }, position: { x: 0, y: 0 } };

            let currentPathSegment = null;

            let tempPathSegments = [];

            let pathHolder = [
                { 
                    id: 0,
                    startPoint: { x: 434, y: 872, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null },
                    endPoint: { x: 325, y: 142, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null },
                    currentPoint: { x: 434, y: 872, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null },
                    openSet: [
                    ],
                    closedSet: [
                    ],
                    segments: [
                        { index: 0, p0: { x: 434, y: 872, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 580, y: 749, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 507, y: 810.5 }, length: 190.90573590125572 },
                        { index: 1, p0: { x: 580, y: 749, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 581, y: 585, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 580.5, y: 667 }, length: 164.00304875214974 },
                        { index: 2, p0: { x: 581, y: 585, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 678, y: 496, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 629.5, y: 540.5 }, length: 131.64345787011217 },
                        { index: 3, p0: { x: 678, y: 496, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 751, y: 430, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 714.5, y: 463 }, length: 98.41239759298622 },
                        { index: 4, p0: { x: 751, y: 430, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 750, y: 260, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 750.5, y: 345 }, length: 170.00294115102832 },
                        { index: 5, p0: { x: 678, y: 496, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 575, y: 384, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 626.5, y: 440 }, length: 152.16109883935513 },
                        { index: 6, p0: { x: 581, y: 585, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 478, y: 466, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 529.5, y: 525.5 }, length: 157.3848785620779 },
                        { index: 7, p0: { x: 478, y: 466, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 482, y: 248, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 480, y: 357 }, length: 218.03669415949233 },
                        { index: 8, p0: { x: 632, y: 117, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 482, y: 248, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 557, y: 182.5 }, length: 199.15069670980316 },
                        { index: 9, p0: { x: 325, y: 142, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 482, y: 248, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 403.5, y: 195 }, length: 189.4333655932872 },
                        { index: 10, p0: { x: 434, y: 872, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 264, y: 763, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 349, y: 817.5 }, length: 201.94306128213466 },
                        { index: 11, p0: { x: 264, y: 763, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 267, y: 595, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 265.5, y: 679 }, length: 168.02678357928536 },
                        { index: 12, p0: { x: 267, y: 595, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, p1: { x: 119, y: 453, walkable: true, distToEnd: 0, hCost: 0, gCost: 0, get fCost() { return this.gCost + this.hCost; } , parentPoint: null }, centerPoint: { x: 193, y: 524 }, length: 205.10485123467947 },
                    ] 
                }
            ];

            if ( DEBUG === true ) {

                rebuildDebugElements();

            }

            //---

            function initGUI() {
            
                const _drawPath = () => {
                
                    editorMode = EDITOR_MODE_ENUM.drawPath;
                
                }
                
                const _setstartPosition = () => {
                
                    editorMode = EDITOR_MODE_ENUM.setstartPosition;
                
                }
                
                const _setendPosition = () => {
                
                    editorMode = EDITOR_MODE_ENUM.setendPosition;
                
                }

                const _getPathSegment = () => {

                    editorMode = EDITOR_MODE_ENUM.getPathSegment;

                }
                
                const _clearAll = () => {

                    const pathIndex = 0;

                    currentPathSegment = null;
                    //pathSegments = [];
                    pathHolder[ pathIndex ] = { 
                        id: pathIndex,
                        startPoint: null,
                        endPoint: null,
                        currentPoint: null,
                        openSet: [],
                        closedSet: [],
                        segments: [] 
                    }

                    removeDebugElements();
                
                }

                const _sortPath = () => {

                    sortPath( pathHolder[ 0 ] );

                }

                const _logPath = () => {
                
                    //console.log( pathHolder[ 0 ].segments );

                    const pathIndex = 0;

                    const path = pathHolder[ pathIndex ];

                    let output = '';

                    output += 'id: ' + pathIndex + ',\n';
                    output += 'startPoint: ' + '{ x: ' + path.startPoint.x + ', y: ' + path.startPoint.y + ', walkable: ' + path.startPoint.walkable + ', distToEnd: ' + path.startPoint.distToEnd + ', hCost: ' + path.startPoint.hCost + ', gCost: ' + path.startPoint.gCost + ', get fCost() { return this.gCost + this.hCost; } ' + ', parentPoint: ' + path.startPoint.parentPoint + ' },' + '\n';
                    output += 'endPoint: ' + '{ x: ' + path.endPoint.x + ', y: ' + path.endPoint.y + ', walkable: ' + path.endPoint.walkable + ', distToEnd: ' + path.endPoint.distToEnd + ', hCost: ' + path.endPoint.hCost + ', gCost: ' + path.endPoint.gCost + ', get fCost() { return this.gCost + this.hCost; } ' + ', parentPoint: ' + path.endPoint.parentPoint + ' },' + '\n';
                    output += 'currentPoint: ' + '{ x: ' + path.currentPoint.x + ', y: ' + path.currentPoint.y + ', walkable: ' + path.currentPoint.walkable + ', distToEnd: ' + path.currentPoint.distToEnd + ', hCost: ' + path.currentPoint.hCost + ', gCost: ' + path.currentPoint.gCost + ', get fCost() { return this.gCost + this.hCost; } ' + ', parentPoint: ' + path.currentPoint.parentPoint + ' },' + '\n';
                    output += 'openSet: [' + '\n';

                    for ( let i = 0, l = path.openSet.length; i < l; i ++ ) {

                        const point = path.openSet[ i ];

                        output += '    { x: ' + point.x + ', y: ' + point.y + ', walkable: ' + point.walkable + ', distToEnd: ' + point.distToEnd + ', hCost: ' + point.hCost + ', gCost: ' + point.gCost + ', get fCost() { return this.gCost + this.hCost; } ' + ', parentPoint: ' + point.parentPoint + ' }';

                        if ( i < l ) {

                            output += ',\n';

                        } else {

                            output += '\n';

                        }

                    }

                    output += '],' + '\n';
                    output += 'closedSet: [' + '\n';

                    for ( let i = 0, l = path.closedSet.length; i < l; i ++ ) {

                        const point = path.closedSet[ i ];

                        output += '    { x: ' + point.x + ', y: ' + point.y + ', walkable: ' + point.walkable + ', distToEnd: ' + point.distToEnd + ', hCost: ' + point.hCost + ', gCost: ' + point.gCost + ', get fCost() { return this.gCost + this.hCost; } ' + ', parentPoint: ' + point.parentPoint + ' }';

                        if ( i < l ) {

                            output += ',\n';

                        } else {

                            output += '\n';

                        }

                    }

                    output += '],' + '\n';
                    output += 'segments: [' + '\n';

                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                        const pathSegment = path.segments[ i ];

                        console.log(pathSegment);

                        output += '    { index: ' + pathSegment.index + ', p0: ' + '{ x: ' + pathSegment.p0.x + ', y: ' + pathSegment.p0.y + ', walkable: ' + pathSegment.p0.walkable + ', distToEnd: ' + pathSegment.p0.distToEnd + ', hCost: ' + pathSegment.p0.hCost + ', gCost: ' + pathSegment.p0.gCost + ', get fCost() { return this.gCost + this.hCost; } ' + ', parentPoint: ' + pathSegment.p0.parentPoint + ' }' + ', p1: ' + '{ x: ' + pathSegment.p1.x + ', y: ' + pathSegment.p1.y + ', walkable: ' + pathSegment.p1.walkable + ', distToEnd: ' + pathSegment.p1.distToEnd + ', hCost: ' + pathSegment.p1.hCost + ', gCost: ' + pathSegment.p1.gCost + ', get fCost() { return this.gCost + this.hCost; } ' + ', parentPoint: ' + pathSegment.p1.parentPoint + ' }' + ', centerPoint: ' + '{ x: ' + pathSegment.centerPoint.x + ', y: ' + pathSegment.centerPoint.y + ' }' + ', length: ' + pathSegment.length + ' }';

                        if ( i < l ) {

                            output += ',\n';

                        } else {

                            output += '\n';

                        }

                    }

                    output += ']' + '\n';

                    console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );
                    console.log( output );
                    console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );

                }

                const _testPath = () => {
                    
                    testPath();
                
                }
                
                const _linkTo = () => {
                
                    window.open( 'https://twitter.com/niklaswebdev', '_blank' );
                
                }
                
                //---
                
                const guiSetting = {
                        
                    'Draw Path': _drawPath,
                    'Set Start Point': _setstartPosition,
                    'Set End Point': _setendPosition,
                    'Sort Path': _sortPath,
                    'Clear All': _clearAll,
                    'Get PathSegment': _getPathSegment,
                    'Log Path': _logPath,
                    'Test Path': _testPath,
                    '@niklaswebdev': _linkTo
                    
                }

                const gui = new dat.GUI();

                const folderEdit = gui.addFolder( 'Edit' );

                folderEdit.open();
                folderEdit.add( guiSetting, 'Draw Path' );
                folderEdit.add( guiSetting, 'Set Start Point' );
                folderEdit.add( guiSetting, 'Set End Point' );
                folderEdit.add( guiSetting, 'Clear All' );

                const folderAnalyze = gui.addFolder( 'Analyze' );

                folderAnalyze.open();
                //folderAnalyze.add( guiSetting, 'Sort Path' );
                folderAnalyze.add( guiSetting, 'Get PathSegment' );
                folderAnalyze.add( guiSetting, 'Log Path' );
                folderAnalyze.add( guiSetting, 'Test Path' );

                const folderContact = gui.addFolder( 'Contact' );

                folderContact.add( guiSetting, '@niklaswebdev' );

                //gui.close();

            }

            //---

            function init() {
                
                canvas.addEventListener( 'mousedown', mouseDownHandler, false );
                //canvas.addEventListener( 'mouseup', mouseUpHandler, false );
                canvas.addEventListener( 'mousemove', mouseMoveHandler, false );

                document.body.appendChild( canvas );

                window.addEventListener( 'resize', onResize, false );

                restart();

            }

            function onResize( event ) {
                
                restart();

            }

            function restart() {

                width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                canvas.width = width;
                canvas.height = height;

                imageData = context.getImageData( 0, 0, width, height );
                data = imageData.data;
                
                //---

                border.right = width;
                border.bottom = height;

                //---
                
                if ( animationFrame !== null ) {
                
                    cancelAnimFrame( animationFrame );
                
                }
                
                animationFrame = requestAnimFrame( render );

            }

            //---








            function getNextPathSegmentsByPoint( point, pathSegments ) {

                const pathSegmentsFound = [];

                //for ( let i = pathSegments.length - 1, l = -1; i > l; i -- ) {
                for ( let i = 0, l = pathSegments.length; i < l; i ++ ) {

                    const pathSegment = pathSegments[ i ];

                    if ( point.x === pathSegment.p0.x && point.y === pathSegment.p0.y ) {

                        pathSegmentsFound.push( pathSegment );
                    
                    } else if ( point.x === pathSegment.p1.x && point.y === pathSegment.p1.y ) {

                        pathSegmentsFound.push( pathSegment );
                    
                    }

                }

                return pathSegmentsFound;

            }

            function getNextPointsByCurrentPointAndNextPathSegments( point, nextPathSegments ) {

                const pointsFound = [];

                for ( let i = 0, l = nextPathSegments.length; i < l; i ++ ) {

                    const nextPathSegment = nextPathSegments[ i ];

                    if ( point.x === nextPathSegment.p0.x && point.y === nextPathSegment.p0.y ) {

                        pointsFound.push( nextPathSegment.p1 );

                    } else if ( point.x === nextPathSegment.p1.x && point.y === nextPathSegment.p1.y ) {

                        pointsFound.push( nextPathSegment.p0 );

                    }

                }

                return pointsFound;

            }

            function testPath() {

                tempPathSegments = [];

                //---

                const pathIndex = 0;

                const path = pathHolder[ pathIndex ];

                path.openSet = [];
                path.closedSet = [];

                path.currentPoint = path.startPoint;
                path.currentPoint.gCost = 0;
                path.currentPoint.hCost = getDistance( path.currentPoint, path.endPoint );

                path.openSet.push( path.currentPoint );

                let iteration = 0;

                while ( path.openSet.length > 0 && iteration < 999 ) {

                    console.log( '______________________________________' );

                    

                    

                    console.log( path.currentPoint.x, path.currentPoint.y );

                    if ( path.currentPoint.x === path.endPoint.x && path.currentPoint.y === path.endPoint.y ) {

                        console.log( 'FOUND END' );

                        const pathToEnd = [];

                        let currentPoint = path.currentPoint;

                        while ( currentPoint !== null ) {

                            pathToEnd.push( currentPoint );

                            currentPoint = currentPoint.parentPoint;

                        }

                        pathToEnd.reverse();

                        for ( let i = 0, l = pathToEnd.length - 1; i < l; i ++ ) {

                            const point0 = pathToEnd[ i ];
                            const point1 = pathToEnd[ i + 1 ];

                            tempPathSegments.push( { type: 'line', p0: { x: point0.x, y: point0.y }, p1: { x: point1.x, y: point1.y } } );

                        }

                        //tempPathSegments.push( { type: 'line', p0: { x: pathSegment.p0.x, y: pathSegment.p0.y }, p1: { x: pathSegment.p1.x, y: pathSegment.p1.y } } );
                        //tempPathSegments.push( { type: 'circ', position: { x: pathSegment.p0.x, y: pathSegment.p0.y }, diameter: 20, color: { r: 255, g: 0, b: 255, a: 255 }  } );
                        //tempPathSegments.push( { type: 'circ', position: { x: pathSegment.p1.x, y: pathSegment.p1.y }, diameter: 20, color: { r: 0, g: 255, b: 255, a: 255 }  } );

                        return;

                    } else {

                        const nextPathSegments = getNextPathSegmentsByPoint( path.currentPoint, path.segments );

                        if ( nextPathSegments.length > 0 ) {

                            const nextPoints = getNextPointsByCurrentPointAndNextPathSegments( path.currentPoint, nextPathSegments );

                            //console.log( nextPoints );

                            for ( let i = 0, l = nextPoints.length; i < l; i ++ ) {

                                const nextPoint = nextPoints[ i ];

                                nextPoint.parentPoint = path.currentPoint;
                                nextPoint.gCost = getDistance( nextPoint, nextPoint.parentPoint );
                                nextPoint.hCost = getDistance( nextPoint, path.endPoint );

                                //console.log( nextPoint.x, nextPoint.y, nextPoint.gCost, nextPoint.hCost, nextPoint.fCost );

                                const isInClosedSet = typeof path.closedSet.find( ( point ) => point.x === nextPoint.x && point.y === nextPoint.y ) === 'undefined' ? false : true;

                                if ( isInClosedSet === false ) {

                                    path.openSet.push( nextPoint );

                                }
                                

                            }

                            path.openSet.splice( path.openSet.findIndex( ( point ) => point.x === path.currentPoint.x && point.y === path.currentPoint.y ), 1 );

                            path.closedSet.push( path.currentPoint );

                            //console.log( path.openSet );
                            //console.log( path.closedSet );

                            /*
                            for ( let i = 0, l = path.openSet.length; i < l; i ++ ) {

                                const nextPoint = nextPoints[ i ];

                                console.log( nextPoint.x, nextPoint.y, nextPoint.fCost );


                            }
                            */
                            
                            //console.log( Math.min( ...path.openSet.map( nextPoint => nextPoint.fCost ) ) );

                            //console.log( path.openSet.find( element => element.fCost === Math.min( ...path.openSet.map( nextPoint => nextPoint.fCost ) ) ) );

                            path.currentPoint = path.openSet.find( element => element.fCost === Math.min( ...path.openSet.map( nextPoint => nextPoint.fCost ) ) );



                            

                        }

                    }

                    


                    /*
                    for ( let i = 1, l = path.openSet.length; i < l; i ++ ) {

                        const nextPoint = path.openSet[ i ];

                        nextPoint.parentPoint = path.currentPoint;
                        nextPoint.gCost = getDistance( nextPoint, nextPoint.parentPoint );
                        nextPoint.hCost = getDistance( nextPoint, path.endPoint );

                        if ( nextPoint.fCost < path.currentPoint.fCost || nextPoint.fCost == path.currentPoint.fCost && nextPoint.hCost < path.currentPoint.hCost ) {
                            
                            path.currentPoint = nextPoint;
                            //console.log( 'path.currentPoint: ', path.currentPoint.x, path.currentPoint.y );

                        }

                    }
                    console.log( 'path.currentPoint: ', path.currentPoint.x, path.currentPoint.y );
                    console.log( 'path.openSet.length: ', path.openSet.length );

                    path.openSet.splice( path.openSet.findIndex( ( point ) => point.x === path.currentPoint.x && point.y === path.currentPoint.y ), 1 );

                    console.log( 'path.openSet.length: ', path.openSet.length );

                    path.closedSet.push( path.currentPoint );

                    const nextPathSegments = getNextPathSegmentsByPoint( path.currentPoint, path.segments );

                    if ( nextPathSegments.length > 0 ) {

                        const nextPoints = getNextPointsByCurrentPointAndNextPathSegments( path.currentPoint, nextPathSegments );

                        console.log( nextPoints );

                        for ( let i = 0, l = nextPoints.length; i < l; i ++ ) {

                            const nextPoint = nextPoints[ i ];

                            nextPoint.parentPoint = path.currentPoint;
                            nextPoint.gCost = getDistance( nextPoint, nextPoint.parentPoint );
                            nextPoint.hCost = getDistance( nextPoint, path.endPoint );

                            console.log( nextPoint.gCost, nextPoint.hCost, nextPoint.fCost );

 
                            const isInClosedSet = typeof path.closedSet.find( ( point ) => point.x === nextPoint.x && point.y === nextPoint.y ) === 'undefined' ? false : true;

                            if ( nextPoint.walkable === false || isInClosedSet === true ) {

                                return;

                            }

                            const newMovementCost = path.currentPoint.gCost + getDistance( path.currentPoint, nextPoint );

                            //path.openSet.push( nextPoint );

                            const isInOpenSet = typeof path.openSet.find( ( point ) => point.x === nextPoint.x && point.y === nextPoint.y ) === 'undefined' ? false : true;


                            if ( newMovementCost < nextPoint.gCost || isInOpenSet === false ) {

                                nextPoint.gCost = newMovementCost;
                                nextPoint.hCost = nextPoint.hCost;
                                nextPoint.parentPoint = path.currentNode;

                                if ( isInOpenSet === false ) {

                                    path.openSet.push( nextPoint );

                                }

                            }

                        }

                    }
                    */









                    console.log( iteration );
                    iteration++;

                }


                /*
                const nextPathSegments = getNextPathSegmentsByPoint( path.currentPoint, path.segments );

                if ( nextPathSegments.length > 0 ) {

                    const nextPoints = getNextPointsByCurrentPointAndNextPathSegments( path.currentPoint, nextPathSegments );

                    console.log( nextPoints );

                    for ( let i = 0, l = nextPoints.length; i < l; i ++ ) {

                        const nextPoint = nextPoints[ i ];

                        nextPoint.parentPoint = path.currentPoint;
                        nextPoint.gCost = getDistance( nextPoint, nextPoint.parentPoint );
                        nextPoint.hCost = getDistance( nextPoint, path.endPoint );

                        console.log( nextPoint.gCost, nextPoint.hCost, nextPoint.fCost );

                        //path.openSet.push( nextPoint );

                    }

                }

                //path.closedSet.push( path.currentPoint );
                */

                /*
                const point = {

                    x: position.x,
                    y: position.y,
                    walkable: walkable,
                    distToEnd: distToEnd,
                    hCost: hCost,
                    gCost: gCost,
                    get fCost() {

                        return this.hCost + this.gCost;

                    },
                    parentPoint: parentPoint

                };
                */

                /*
                id: 0,
                    startPoint: { x: 519, y: 889, distToEnd: 0 },
                    endPoint: { x: 397, y: 117, distToEnd: 0 },
                    currentPoint: null,
                    openSet: [],
                    closedSet: [],
                    segments: [
                        */

                /*
                const pathSegments = [ ...pathHolder[ 0 ].segments ];

                const startPoint = pathHolder[ 0 ].startPoint;
                const endPoint = pathHolder[ 0 ].endPoint;

                //---

                const currentPoint = startPoint;

                //---

                const nextPathSegments = getNextPathSegmentsByPoint( currentPoint, pathSegments );

                console.log( nextPathSegments );





                //const nextPathSegment = nextPathSegments[ i ];

                if ( nextPathSegments.length > 0 ) {

                    const nextPoints = getNextPointsByCurrentPointAndNextPathSegments( currentPoint, nextPathSegments );

                    console.log( nextPoints );

                }
                */







                const test = () => {

                    const nextTiles = [];

                    for ( let i = pathSegments.length - 1, l = -1; i > l; i -- ) {

                        const pathSegment = pathSegments[ i ];

                        //if ( pathSegmentCurrent.index !== pathSegment.index ) {

                            if ( pathSegmentCurrent.p1.x === pathSegment.p0.x && pathSegmentCurrent.p1.y === pathSegment.p0.y ) {

                                //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );
                                //_nextPathSegments.push( { segment: pathSegments.sclice( i, 1 )[ 0 ], index: i } );

                                const nPS = pathSegments.splice( i, 1 )[ 0 ];

                                //_nextPathSegments.push( nPS );
                                //pathSegmentsSave.push( nPS );

                                nextTiles.push( nPS );

                            }

                            if ( pathSegmentCurrent.p1.x === pathSegment.p1.x && pathSegmentCurrent.p1.y === pathSegment.p1.y ) {

                                //flipPathSegmentStartEnd( pathSegment );

                                //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                                const nPS = pathSegments.splice( i, 1 )[ 0 ];

                                //_nextPathSegments.push( nPS );
                                //pathSegmentsSave.push( nPS );

                                nextTiles.push( nPS );

                            }

                            if ( pathSegmentCurrent.p0.x === pathSegment.p0.x && pathSegmentCurrent.p0.y === pathSegment.p0.y ) {

                                //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                                const nPS = pathSegments.splice( i, 1 )[ 0 ];

                                //_nextPathSegments.push( nPS );
                                //pathSegmentsSave.push( nPS );

                                nextTiles.push( nPS );

                            }

                            if ( pathSegmentCurrent.p0.x === pathSegment.p1.x && pathSegmentCurrent.p0.y === pathSegment.p1.y ) {

                                //flipPathSegmentStartEnd( pathSegment );

                                //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                                const nPS = pathSegments.splice( i, 1 )[ 0 ];

                                //_nextPathSegments.push( nPS );
                                //pathSegmentsSave.push( nPS );

                                nextTiles.push( nPS );

                            }

                        //}
                        
                    }

                    console.log( nextTiles );

                };

                //test();

            }

            /*
            function testPath() {

                const pathSegments = [ ...pathHolder[ 0 ].segments ];
                const pathSegmentsLookUp = [ ...pathSegments ];

                //---

                const pathes = [];
                const pathesIndex = 0;

                pathes[ pathesIndex ] = { id: pathesIndex, segments: [], totalLength: 0, foundEnd: false }

                //---

                const pathSegmentStart = pathSegments.find( pathSegment => pathSegment.startPosition !== null );
                //const pathStartPosition = pathSegmentStart.startPosition;
                //const pathSegmentStartIndex = pathSegments.findIndex( pathSegment => pathSegment.startPosition !== null );
                //const pathSegmentStart = pathSegments.splice( pathSegmentStartIndex, 1 )[ 0 ];

                const pathSegmentEnd = pathSegments.find( pathSegment => pathSegment.endPosition !== null );
                //const pathEndPosition = pathSegmentEnd.endPosition;

                //---

                recursive( pathSegments, pathSegmentsLookUp, pathes, 0, pathesIndex, 0, pathSegmentStart, [], [], [], pathSegmentStart, pathSegmentEnd );

                //---

                console.log( 'testDone()' );
                //console.log( pathes );

                for ( let i = 0, l = pathes.length; i < l; i ++ ) {

                    const p = pathes[ i ];

                    console.log( 'path ', i.toString(), '(foundEnd: ' + p.foundEnd + ', totalLength: ' + p.totalLength + '):' );

                    for ( let j = 0, m = p.segments.length; j < m; j ++ ) {

                        if ( p.foundEnd === true ) {

                            p.segments[ j ].sorted = true;

                        }

                        console.log( p.segments[ j ].index, ' - ', p.segments[ j ].length );
                        //console.log( p.segments[ j ] );

                    }

                }

            }

            function recursive( pathSegments, pathSegmentsLookUp, pathes, pathCurrentIndex, index, iteration, pathSegmentCurrent, splitpointsIndices, pathSegmentsSave, pathSegmentsSavecurrent, pathSegmentStart, pathSegmentEnd ) {
                console.log('-------------------------recursive-------------------------');
                pathSegmentsSavecurrent.push( pathSegmentCurrent );

                let output_pathSegmentsSavecurrent0 = '[pathSegmentsSavecurrent]: [';
                for ( let i = 0, l = pathSegmentsSavecurrent.length; i < l; i ++ ) {
                    output_pathSegmentsSavecurrent0 += i === l - 1 ? pathSegmentsSavecurrent[ i ].index : pathSegmentsSavecurrent[ i ].index + ', ';
                }
                output_pathSegmentsSavecurrent0 += ']';
                console.log( output_pathSegmentsSavecurrent0 );



                pathes[ index ].segments.push( pathSegmentCurrent );
                pathes[ index ].totalLength += pathSegmentCurrent.length;

                if ( pathSegmentCurrent.p0.x === pathSegmentEnd.endPosition.x && pathSegmentCurrent.p0.y === pathSegmentEnd.endPosition.y ||
                     pathSegmentCurrent.p1.x === pathSegmentEnd.endPosition.x && pathSegmentCurrent.p1.y === pathSegmentEnd.endPosition.y ) {

                    pathes[ index ].foundEnd = true;

                }

                //if ( index === 0 && pathSegmentCurrent.index !==  ) {

                    //console.log( '--> ', pathSegmentCurrent );

                //}

                //iteration++;

                //---

                const _nextPathSegments = [];
                const _pathSegmentsLength = pathSegments.length;

                for ( let i = _pathSegmentsLength - 1, l = -1; i > l; i -- ) {

                    const pathSegment = pathSegments[ i ];

                    if ( pathSegmentCurrent.index !== pathSegment.index ) {

                        if ( pathSegmentCurrent.p1.x === pathSegment.p0.x && pathSegmentCurrent.p1.y === pathSegment.p0.y ) {

                            //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );
                            //_nextPathSegments.push( { segment: pathSegments.sclice( i, 1 )[ 0 ], index: i } );

                            const nPS = pathSegments.splice( i, 1 )[ 0 ];

                            _nextPathSegments.push( nPS );
                            pathSegmentsSave.push( nPS );

                        }

                        if ( pathSegmentCurrent.p1.x === pathSegment.p1.x && pathSegmentCurrent.p1.y === pathSegment.p1.y ) {

                            //flipPathSegmentStartEnd( pathSegment );

                            //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                            const nPS = pathSegments.splice( i, 1 )[ 0 ];

                            _nextPathSegments.push( nPS );
                            pathSegmentsSave.push( nPS );

                        }

                        if ( pathSegmentCurrent.p0.x === pathSegment.p0.x && pathSegmentCurrent.p0.y === pathSegment.p0.y ) {

                            //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                            const nPS = pathSegments.splice( i, 1 )[ 0 ];

                            _nextPathSegments.push( nPS );
                            pathSegmentsSave.push( nPS );

                        }

                        if ( pathSegmentCurrent.p0.x === pathSegment.p1.x && pathSegmentCurrent.p0.y === pathSegment.p1.y ) {

                            //flipPathSegmentStartEnd( pathSegment );

                            //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                            const nPS = pathSegments.splice( i, 1 )[ 0 ];

                            _nextPathSegments.push( nPS );
                            pathSegmentsSave.push( nPS );

                        }

                    }
                      
                }

                //---



                //---

                //console.log( _nextPathSegments );

                //---

                if ( _nextPathSegments.length > 1 ) {

                    splitpointsIndices.push( { index: pathCurrentIndex, count: _nextPathSegments.length - 1 } );

                }

                if ( _nextPathSegments.length > 0 ) {

                    //let nextPathSegment = _nextPathSegments[ 0 ];

                    if ( pathCurrentIndex === 0 && _nextPathSegments.length > 1 ) {

                        let followPathSegmentIndex = -1;

                        for ( let i = _nextPathSegments.length - 1, l = -1; i > l; i -- ) {

                            const _nPS = _nextPathSegments[ i ];

                            if ( _nPS.p0 !== null && pathSegmentCurrent.startPosition !== null ) {

                                if ( _nPS.p0.x !== pathSegmentCurrent.startPosition.x && _nPS.p0.y !== pathSegmentCurrent.startPosition.y &&
                                     _nPS.p1.x !== pathSegmentCurrent.startPosition.x && _nPS.p1.y !== pathSegmentCurrent.startPosition.y ) {

                                    followPathSegmentIndex = i;

                                    break;

                                }

                            }

                        }

                        if ( followPathSegmentIndex > -1 ) {

                            nextPathSegment = _nextPathSegments.splice( followPathSegmentIndex, 1 )[ 0 ];

                        } else {

                            nextPathSegment = _nextPathSegments.shift();

                        }

                        //console.log("sdgdfgsdfgsdfgkjdfhb8e7ortzg9eirhwerighidfughreiubfhrt8o7hv8o725h48o7vrt8gg8o7h4w9p8gjsfgilh249p5gjrtp98zu54ohbjrt54p9z");

                        //splitpoints = [ ...splitpoints, ..._nextPathSegments ];

                    } else {

                        nextPathSegment = _nextPathSegments.shift();

                        //splitpoints = [ ...splitpoints, ..._nextPathSegments ];

                    }

                    //splitpoints = [ ...splitpoints, ..._nextPathSegments ];

                    //console.log( 'nextPathSegment ---> ', nextPathSegment );
                    //console.log( 'splitpoints ---> ', splitpoints );
                    //console.log( 'splitpointsIndices ---> ', splitpointsIndices );
                    //console.log( 'pathSegmentsSave ---> ', pathSegmentsSave );

                    
                    // if ( nextPathSegment.p0.x !== pathSegmentStart.p0.x && nextPathSegment.p0.y !== pathSegmentStart.p0.y &&
                    //      nextPathSegment.p1.x !== pathSegmentStart.p1.x && nextPathSegment.p1.y !== pathSegmentStart.p1.y ) {

                    //         console.log( '---> ', pathSegmentCurrent ); 

                    //         pathes[ index ].segments.push( pathSegmentCurrent );

                    //         pathSegmentCurrent.sorted = true;

                    //         //setTimeout(function(){ alert("Hello"); }, 3000);

                    // }


                    pathCurrentIndex++;

                    //setTimeout( () => {
                        
                        recursive( pathSegments, pathSegmentsLookUp, pathes, pathCurrentIndex, index, iteration, nextPathSegment, splitpointsIndices, pathSegmentsSave, pathSegmentsSavecurrent, pathSegmentStart, pathSegmentEnd )
                    
                    //}, 250 );
                    



                    
                    // if ( pathSegmentCurrent.startPosition !== null ) {

                    //     //if ( pathSegmentCurrent.startPosition.x !== nextPathSegment.p0.x && pathSegmentCurrent.startPosition.y !== nextPathSegment.p0.y ) {

                            

                    //     //}

                    // } else {

                    //     pathes[ index ].segments.push( pathSegmentCurrent );

                    // }
                    

                    //recursive(  );

                } else {
                    console.log( '-----------------------------------------------------------------------------------------------------' );
                    //console.log( '//---> ', pathSegmentsSavecurrent );

                    let output_pathSegmentsSavecurrent = '[pathSegmentsSavecurrent]: [';
                    for ( let i = 0, l = pathSegmentsSavecurrent.length; i < l; i ++ ) {
                        output_pathSegmentsSavecurrent += i === l - 1 ? pathSegmentsSavecurrent[ i ].index : pathSegmentsSavecurrent[ i ].index + ', ';
                    }
                    output_pathSegmentsSavecurrent += ']';
                    console.log( output_pathSegmentsSavecurrent );
                    //console.log( '//---> ', pathSegmentsSave );
                    //console.log( '//---> ', pathSegments );
                    //if ( splitpoints.length > 0 ) {

                    let deadEndPathSegments = [];

                    //const deadEndPathSegments = pathSegmentsSavecurrent.splice( 0, splitpointsIndices[ splitpointsIndices.length - 1 ].index + 1 );



                    // Wenn es Duplikate gibt, dann gibt es eine Wiederholung, was bedeutet, dass dieser Part übersprungen werden kann.
                    const valueArr = pathSegmentsSavecurrent.map( ( item ) => { return item.index } );
                    const foundDuplicate = valueArr.some( ( item, idx ) => { return valueArr.indexOf( item ) != idx } );

                    console.log( 'foundDuplicate ---->: ', foundDuplicate );





                    
                    if ( splitpointsIndices.length > 0 ) {

                        deadEndPathSegments = pathSegmentsSavecurrent.splice( splitpointsIndices[ splitpointsIndices.length - 1 ].index + 1, pathSegmentsSavecurrent.length );

                    }
                    

                    //console.log( splitpointsIndices[ splitpointsIndices.length - 1 ].index, pathSegmentsSavecurrent.length );
                    //console.log( '//---> ', deadEndPathSegments );
                    //splitpointsIndices.push( { index: pathCurrentIndex, count: _nextPathSegments.length - 1 } );

                    let output_deadEndPathSegments = '[deadEndPathSegments]: [';
                    for ( let i = 0, l = deadEndPathSegments.length; i < l; i ++ ) {
                        output_deadEndPathSegments += i === l - 1 ? deadEndPathSegments[ i ].index : deadEndPathSegments[ i ].index + ', ';
                    }
                    output_deadEndPathSegments += ']';
                    console.log( output_deadEndPathSegments );
                    
                    //das splitpointsIndices scheint nicht korrekt zu sein, bzw. wird nicht korrekt zurückgesetzt.
                    let output_splitpointsIndices = '[splitpointsIndices]: [';
                    for ( let i = 0, l = splitpointsIndices.length; i < l; i ++ ) {
                        output_splitpointsIndices += i === l - 1 ? splitpointsIndices[ i ].index : splitpointsIndices[ i ].index + ', ';
                    }
                    output_splitpointsIndices += ']';
                    console.log( output_splitpointsIndices );

                    
                    // console.log("sdfsdfdsfsdf ---->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KILLER : ", splitpointsIndices[ splitpointsIndices.length - 1 ].count);
                    // splitpointsIndices[ splitpointsIndices.length - 1 ].count--;
                    
                    // if ( splitpointsIndices[ splitpointsIndices.length - 1 ].count === 0 ) {

                    //     splitpointsIndices.pop();

                    // }
                    

                    if ( deadEndPathSegments.length > 0 ) {

                        splitpointsIndices.pop();

                    }

                    for ( let i = 0, l = deadEndPathSegments.length; i < l; i ++ ) {

                        const deadEndPathSegment = deadEndPathSegments[ i ];

                        //pathSegmentsSave.splice( pathSegmentsSave.findIndex( pS => pS.index === deadEndPathSegment.index ), 1 );
                        //pathSegmentsLookUp.splice( pathSegmentsSave.findIndex( pS => pS.index === deadEndPathSegment.index ), 1 );

                        //console.log( 'ÄÄÄÄÄ: ',  );

                        for ( let j = pathSegmentsLookUp.length - 1, m = -1; j > m; j -- ) {

                            const pS = pathSegmentsLookUp[ j ];

                            if ( pS.index === deadEndPathSegment.index ) {

                                pathSegmentsLookUp.splice( j, 1 );

                            }

                        }

                    }

                    let output_pathSegmentsSave = '[pathSegmentsSave]: [';
                    for ( let i = 0, l = pathSegmentsSave.length; i < l; i ++ ) {
                        output_pathSegmentsSave += i === l - 1 ? pathSegmentsSave[ i ].index : pathSegmentsSave[ i ].index + ', ';
                    }
                    output_pathSegmentsSave += ']';
                    console.log( output_pathSegmentsSave );

                    //console.log( '//---> ', pathSegmentsSave );

                    pathSegments = [ ...pathSegmentsLookUp ];
                    //console.log( '//---> ', pathSegmentsLookUp );

                    let output_pathSegments = '[pathSegments]: [';
                    for ( let i = 0, l = pathSegments.length; i < l; i ++ ) {
                        output_pathSegments += i === l - 1 ? pathSegments[ i ].index : pathSegments[ i ].index + ', ';
                    }
                    output_pathSegments += ']';
                    console.log( output_pathSegments );

                    let output_pathSegmentsLookUp = '[pathSegmentsLookUp]: [';
                    for ( let i = 0, l = pathSegmentsLookUp.length; i < l; i ++ ) {
                        output_pathSegmentsLookUp += i === l - 1 ? pathSegmentsLookUp[ i ].index : pathSegmentsLookUp[ i ].index + ', ';
                    }
                    output_pathSegmentsLookUp += ']';
                    console.log( output_pathSegmentsLookUp );


                    // if ( splitpointsIndices.length === 1 ) {

                    //     if ( splitpointsIndices[ 0 ].index === 0 ) {

                    //         console.log('---> CUT <---');

                    //         //index--;

                    //     }

                    // }


                    pathSegmentsSave = [];
                    pathSegmentsSavecurrent = [];
                    splitpointsIndices = [];
                    //splitpoints = [];

                    nextPathSegment = pathSegments[ 0 ];

                    

                    pathCurrentIndex = 0;




                    if ( foundDuplicate === true ) {

                        pathes[ index ] = { id: index, segments: [], totalLength: 0, foundEnd: false };

                    } else {

                        index++;

                        pathes[ index ] = { id: index, segments: [], totalLength: 0, foundEnd: false };

                    }

                    // index++;

                    // pathes[ index ] = { id: index, segments: [], totalLength: 0, foundEnd: false };

                    //splitpointsIndices

                    // if ( foundDuplicate === false && pathSegments.length > 3 ) {

                    //     recursive( pathSegments, pathSegmentsLookUp, pathes, pathCurrentIndex, index, iteration, nextPathSegment, splitpointsIndices, pathSegmentsSave, pathSegmentsSavecurrent, pathSegmentStart, pathSegmentEnd )
                    
                    // }

                    iteration++;

                    if ( iteration < 11 ) 
                        recursive( pathSegments, pathSegmentsLookUp, pathes, pathCurrentIndex, index, iteration, nextPathSegment, splitpointsIndices, pathSegmentsSave, pathSegmentsSavecurrent, pathSegmentStart, pathSegmentEnd )
                    


                }




                
            }
            */








            //---

            function getPathSegmentPointsByPosition( position ) {

                const pathIndex = 0;

                const path = pathHolder[ pathIndex ];

                const result = [];

                for ( let i = 0, l = path.segments.length; i < l; i ++ ) {
            
                    const pathSegment = path.segments[ i ];

                    if ( pathSegment.p0.x === position.x && pathSegment.p0.y === position.y ) {

                        result.push( pathSegment.p0 );

                    }

                    if ( pathSegment.p1.x === position.x && pathSegment.p1.y === position.y ) {

                        result.push( pathSegment.p1 );

                    }

                }

                return result;

            }

            function getPathSegementPoint( position, walkable = true, distToEnd = 0, gCost = 0, hCost = 0, parentPoint = null ) {

                const point = {

                    x: position.x,
                    y: position.y,
                    walkable: walkable,
                    distToEnd: distToEnd,
                    gCost: gCost,
                    hCost: hCost,
                    get fCost() {

                        return this.gCost + this.hCost;

                    },
                    parentPoint: parentPoint

                };

                return point;

            }

            function addPathSegment( position ) {

                const path = pathHolder[ 0 ];
                
                if ( currentPathSegment === null ) {
            
                    currentPathSegment = {};
                    currentPathSegment.index = path.segments.length;
                    currentPathSegment.p0 = getPathSegementPoint( position );
                    currentPathSegment.p1 = null;
                    //currentPathSegment.startPosition = null;
                    //currentPathSegment.endPosition = null;
                    //currentPathSegment.sorted = false;

                    // const pathSegmentPointsWithSamePosition = getPathSegmentPointsByPosition( currentPathSegment.p0 );

                    // if ( pathSegmentPointsWithSamePosition.length > 1 ) {

                        // pathSegmentPointsWithSamePosition.push( currentPathSegment.p0 );
                        
                        // for ( let i = 0, l = pathSegmentPointsWithSamePosition.length; i < l; i++ ) {

                        //     pathSegmentPointsWithSamePosition[ i ].split = true;

                        // }

                    // }

                    path.segments.push( currentPathSegment );

                    if ( DEBUG === true ) {

                        addDebugElement( position.x, position.y, position.x.toString() + ', ' + position.y.toString(), 'white', 0, 9, null );

                        addDebugElement( position.x, position.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, currentPathSegment.index );

                    } 
                
                } else {

                    currentPathSegment.p1 = getPathSegementPoint( position );
                    currentPathSegment.length = getDistance( currentPathSegment.p0, currentPathSegment.p1 );
                    currentPathSegment.centerPoint = getPathSegmentCenter( currentPathSegment );

                    // const pathSegmentPointsWithSamePosition = getPathSegmentPointsByPosition( currentPathSegment.p1 );

                    // if ( pathSegmentPointsWithSamePosition.length > 2 ) {

                        // pathSegmentPointsWithSamePosition.push( currentPathSegment.p1 );

                        // for ( let i = 0, l = pathSegmentPointsWithSamePosition.length; i < l; i++ ) {

                        //     pathSegmentPointsWithSamePosition[ i ].split = true;

                        // }

                    // }

                    if ( DEBUG === true ) {

                        addDebugElement( position.x, position.y, position.x.toString() + ', ' + position.y.toString(), 'white', 0, 9, null );
                        addDebugElement( currentPathSegment.centerPoint.x, currentPathSegment.centerPoint.y, currentPathSegment.index.toString(), 'black', -3, -5, null );

                        addDebugElement( position.x, position.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, currentPathSegment.index );

                    } 

                    currentPathSegment = null;

                    //---

                    //sortPath( path );
                
                }

            }

            //---
            /*
            function sortPath( path ) {

                //console.log( 'sortPath()' );

                const pathSegmentsSorted = [];
                const pathSegments = path.segments;

                //console.log( pathSegments );

                //---
                
                const pathSegmentStartIndex = pathSegments.findIndex( pathSegment => pathSegment.startPosition !== null );
                const pathSegmentStart = pathSegments.splice( pathSegmentStartIndex, 1 )[ 0 ];

                const pathSegmentEndIndex = pathSegments.findIndex( pathSegment => pathSegment.endPosition !== null );
                const pathSegmentEnd = pathSegments.splice( pathSegmentEndIndex, 1 )[ 0 ];

                //console.log( pathSegmentStartIndex, pathSegmentEndIndex );
                //console.log( pathSegmentStart, pathSegmentEnd );

                //---

                pathSegmentsSorted.push( pathSegmentStart );

                //---

                let _currentPathSegment = pathSegmentStart;
                let _nextPathSegment = null;
                let _pathSegmentsLength = path.segments.length;

                for ( let j = 0; j < _pathSegmentsLength; j++ ) {

                    for ( let i = path.segments.length - 1, l = -1; i > l; i -- ) {

                        const pathSegment = path.segments[ i ];

                        if ( _currentPathSegment.p1.x === pathSegment.p0.x && _currentPathSegment.p1.y === pathSegment.p0.y ) {

                            _nextPathSegment = path.segments.splice( i, 1 )[ 0 ];

                        }

                        if ( _currentPathSegment.p1.x === pathSegment.p1.x && _currentPathSegment.p1.y === pathSegment.p1.y ) {

                            flipPathSegmentStartEnd( pathSegment );

                            _nextPathSegment = path.segments.splice( i, 1 )[ 0 ];

                        }

                    }

                    pathSegmentsSorted.push( _nextPathSegment );

                    _currentPathSegment = _nextPathSegment;

                }

                //---

                pathSegmentsSorted.push( pathSegmentEnd );

                //---

                for ( let i = 0, l = pathSegmentsSorted.length; i < l; i ++ ) {

                    const pathSegment = pathSegmentsSorted[ i ];

                    pathSegment.sorted = true;
                    pathSegment.index = i;

                }

                //---

                path.segments = [ ...pathSegmentsSorted ];

                //---

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

                //console.log( path.segments );
                //console.log( pathSegmentsSorted );
                //console.log( pathHolder[ 0 ].segments );

                //console.log( 'sortPath() done' );

            }
            */
            //---

            /*
            function flipPathSegmentStartEnd( pathSegment ) {

                const p0Temp = { x: pathSegment.p0.x, y: pathSegment.p0.y, split: pathSegment.p0.split };
                const p1Temp = { x: pathSegment.p1.x, y: pathSegment.p1.y, split: pathSegment.p0.split };

                pathSegment.p0.x = p1Temp.x;
                pathSegment.p0.y = p1Temp.y;
                pathSegment.p0.split = p1Temp.split;

                pathSegment.p1.x = p0Temp.x;
                pathSegment.p1.y = p0Temp.y;
                pathSegment.p1.split = p0Temp.split;

            }
            */

            //---






            /*
            function removeStartPositionToPathSegment() {

                const path = pathHolder[ 0 ];

                const pathSegmentsStart = path.segments.filter( pathSegment => pathSegment.startPosition !== null );

                if ( pathSegmentsStart.length > 0 ) {

                    for ( let i = 0, l = pathSegmentsStart.length; i < l; i ++ ) {

                        const pathSegmentStart = pathSegmentsStart[ i ];

                        pathSegmentStart.startPosition = null;

                    }

                }

            }

            function addStartPositionToPathSegment( position ) {

                removeStartPositionToPathSegment();

                //---

                const path = pathHolder[ 0 ];

                for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                    const pathSegment = path.segments[ i ];

                    if ( pathSegment.p0.x === position.x && pathSegment.p0.y === position.y ) {

                        pathSegment.startPosition = { x: position.x, y: position.y };

                    }

                    if ( pathSegment.p1.x === position.x && pathSegment.p1.y === position.y ) {

                        //flipPathSegmentStartEnd( pathSegment );

                        pathSegment.startPosition = { x: position.x, y: position.y };

                    }

                }

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }

            function removeEndPositionToPathSegment() {

                const path = pathHolder[ 0 ];

                const pathSegmentsEnd = path.segments.filter( pathSegment => pathSegment.endPosition !== null );

                if ( pathSegmentsEnd.length > 0 ) {

                    for ( let i = 0, l = pathSegmentsEnd.length; i < l; i ++ ) {

                        const pathSegmentEnd = pathSegmentsEnd[ i ];

                        pathSegmentEnd.endPosition = null;

                    }

                }

            }

            function addEndPositionToPathSegment( position ) {

                removeEndPositionToPathSegment();

                //---

                const path = pathHolder[ 0 ];

                for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                    const pathSegment = path.segments[ i ];

                    if ( pathSegment.p0.x === position.x && pathSegment.p0.y === position.y ) {

                        pathSegment.endPosition = { x: position.x, y: position.y };

                    }

                    if ( pathSegment.p1.x === position.x && pathSegment.p1.y === position.y ) {

                        //flipPathSegmentStartEnd( pathSegment );

                        pathSegment.endPosition = { x: position.x, y: position.y };

                    }

                }

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }
            */

            function addStartPointToPath( pathIndex, position ) {

                const path = pathHolder[ pathIndex ];

                path.startPoint = getPathSegmentPointsByPosition( position )[ 0 ];

                path.currentPoint = path.startPoint;

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }

            function addEndPointToPath( pathIndex, position ) {

                const path = pathHolder[ pathIndex ];

                path.endPoint = getPathSegmentPointsByPosition( position )[ 0 ];

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }










            //---

            function rebuildDebugElements() {

                removeDebugElements();

                //---

                const path = pathHolder[ 0 ];

                if ( path.startPoint !== null ) {

                    addDebugElement( path.startPoint.x, path.startPoint.y, 'START', 'white', -15, -25, null );

                }

                if ( path.endPoint !== null ) {

                    addDebugElement( path.endPoint.x, path.endPoint.y, 'END', 'white', -15, -25, null );

                }

                path.segments.forEach( ( pathSegment, index ) => {

                    if ( index < path.segments.length - 1 ) {

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, pathSegment.p0.x.toString() + ', ' + pathSegment.p0.y.toString(), 'white', 0, 9, null );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, pathSegment.p1.x.toString() + ', ' + pathSegment.p1.y.toString(), 'white', 0, 9, null );

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );

                    } else {

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, pathSegment.p0.x.toString() + ', ' + pathSegment.p0.y.toString(), 'white', 0, 9, null );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, pathSegment.p1.x.toString() + ', ' + pathSegment.p1.y.toString(), 'white', 0, 9, null );

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );

                    }

                    addDebugElement( pathSegment.centerPoint.x, pathSegment.centerPoint.y, pathSegment.index.toString(), 'black', -3, -5, null );

                } );

            }

            function removeDebugElements() {

                debugElements.forEach( ( debugElement, index ) => {

                    document.body.removeChild( debugElement );

                } );

                debugElements = [];

            }

            function addDebugElement( x, y, message, color = 'white', offsetX = 0, offsetY = 0, className = null ) {

                const debugElement = document.createElement( 'div' );

                debugElement.style.position = 'absolute';
                debugElement.style.left = ( x + offsetX ).toString() + 'px';
                debugElement.style.top = ( y + offsetY ).toString() + 'px';
                debugElement.style.color = color;
                debugElement.style.fontSize = '8pt';
                debugElement.style.pointerEvents = 'none';

                if ( className === null ) {

                    debugElement.className = 'debug-' + ( new Date().getTime() + debugElements.length ).toString();

                } else {

                    debugElement.className = 'debug-' + className.toString();

                }

                debugElement.innerHTML = message;

                document.body.appendChild( debugElement );

                debugElements.push( debugElement );

            }

            //---

            function getDistance( p1, p2 ) {

                const a = p1.x - p2.x;
                const b = p1.y - p2.y;

                return Math.sqrt( a * a + b * b );
            
            }

            function getPathSegmentCenter( pathSegment ) {

                const x = ( pathSegment.p0.x + pathSegment.p1.x ) / 2;
                const y = ( pathSegment.p0.y + pathSegment.p1.y ) / 2;
            
                return { x: x, y: y };
            
            }

            function signedDistanceToLine( p, p0X, p0Y, p1X, p1Y ) {

                const p0p1X = p0X - p1X;
                const p0p1Y = p0Y - p1Y;

                const l2 = p0p1X * p0p1X + p0p1Y * p0p1Y;

                const pp0X = p.x - p0X;
                const pp0Y = p.y - p0Y;

                if ( l2 === 0 ) {

                    return pp0X * pp0X + pp0Y * pp0Y;

                }

                const p1p0X = p1X - p0X;
                const p1p0Y = p1Y - p0Y;

                const t = clamp( ( pp0X * p1p0X + pp0Y * p1p0Y ) / l2, 0, 1 );

                const ptX = p0X + t * p1p0X;
                const ptY = p0Y + t * p1p0Y;

                const pX = p.x - ptX;
                const pY = p.y - ptY;

                return Math.sqrt( pX * pX + pY * pY );

            }

            //---

            function clamp( val, min, max ) {

                return Math.min( Math.max( min, val ), max );

            }

            //---






            //---

            function mouseDownHandler( event ) {

                // editorMode = EDITOR_MODE_ENUM.drawPath;

                if ( editorMode === EDITOR_MODE_ENUM.drawPath ) {

                    addPathSegment( mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.setstartPosition ) {

                    //addStartPositionToPathSegment( mouseCursor.position );

                    addStartPointToPath( 0, mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.setendPosition ) {

                    //addEndPositionToPathSegment( mouseCursor.position );

                    addEndPointToPath( 0, mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.getPathSegment ) {

                    //addEndPositionToPathSegment( mouseCursor.position );

                }

            }

            function mouseUpHandler( event ) {

                //mouseDown = false;
            
                //mousePosEnd = getMousePos( canvas, event );
            
                //endLineSegment( mousePosEnd );

            }

            function mouseMoveHandler( event ) {

                mousePos = getMousePos( canvas, event );

                if ( editorMode === EDITOR_MODE_ENUM.getPathSegment ) {

                    tempPathSegments = [];

                    //---

                    let distanceTotal = Infinity;
                    let indexSave = -1;

                    pathHolder.forEach( ( path, index ) => {
                
                        for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                            const pathSegment = path.segments[ i ];

                            const distanceToPathSegment = signedDistanceToLine( mousePos, pathSegment.p0.x, pathSegment.p0.y, pathSegment.p1.x, pathSegment.p1.y );

                            if ( distanceToPathSegment < distanceTotal ) {

                                distanceTotal = distanceToPathSegment;

                                indexSave = i;

                            }

                        }

                    } );
                    
                    if ( indexSave > -1 && distanceTotal <= SNAP_TO_DISTANCE ) {

                        const pathSegment = pathHolder[ 0 ].segments[ indexSave ];

                        // console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );
                        // console.log( 'PATH ID: ', pathSegment.index );
                        // console.log( 'p0: ', pathSegment.p0 );
                        // console.log( 'p1: ', pathSegment.p1 );
                        // console.log( 'startPosition: ', pathSegment.startPosition );
                        // console.log( 'endPosition: ', pathSegment.endPosition );
                        // console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );

                        tempPathSegments.push( { type: 'line', p0: { x: pathSegment.p0.x, y: pathSegment.p0.y }, p1: { x: pathSegment.p1.x, y: pathSegment.p1.y } } );
                        tempPathSegments.push( { type: 'circ', position: { x: pathSegment.p0.x, y: pathSegment.p0.y }, diameter: 20, color: { r: 255, g: 0, b: 255, a: 255 }  } );
                        tempPathSegments.push( { type: 'circ', position: { x: pathSegment.p1.x, y: pathSegment.p1.y }, diameter: 20, color: { r: 0, g: 255, b: 255, a: 255 }  } );

                    }

                }

            }

            function getMousePos( canvas, event ) {

                const rect = canvas.getBoundingClientRect();

                return { x: event.clientX - rect.left, y: event.clientY - rect.top };

            }

            //---

            function clearImageData() {

                for ( let i = 0, l = data.length; i < l; i += 4 ) {

                    data[ i ] = 0;
                    data[ i + 1 ] = 0;
                    data[ i + 2 ] = 0;
                    data[ i + 3 ] = 0;

                }

            }

            function setPixel( x, y, r, g, b, a ) {

                const i = ( x + y * imageData.width ) * 4;

                data[ i ] = r;
                data[ i + 1 ] = g;
                data[ i + 2 ] = b;
                data[ i + 3 ] = a;

            }

            //---

            function drawLine( x1, y1, x2, y2, r, g, b, a ) {

                const dx = Math.abs( x2 - x1 );
                const dy = Math.abs( y2 - y1 );

                const sx = ( x1 < x2 ) ? 1 : -1;
                const sy = ( y1 < y2 ) ? 1 : -1;

                let err = dx - dy;

                let lx = x1;
                let ly = y1;    

                while ( true ) {

                    if ( lx > 0 && lx < width && ly > 0 && ly < height ) {

                        setPixel( lx, ly, r, g, b, a );

                    }

                    if ( ( lx === x2 ) && ( ly === y2 ) ) {
                    
                        break;
                    
                    }

                    const e2 = 2 * err;

                    if ( e2 > -dx ) { 

                        err -= dy; 
                        lx += sx; 

                    }

                    if ( e2 < dy ) { 

                        err += dx; 
                        ly += sy; 

                    }

                }

            }

            function drawCircle( vector, radius, r, g, b, a ) {
                
                const radius2 = radius * radius;

                if ( radius === 1 ) {

                    if ( vector.x > border.left && vector.x < border.right && vector.y > border.top && vector.y < border.bottom ) {

                        setPixel( vector.x2d | 0, vector.y2d | 0, r, g, b, a );

                    }

                    return;

                }
                
                if ( vector.x + radius < border.left || vector.x - radius > border.right || vector.y + radius < border.top || vector.y - radius > border.bottom ) {

                    return;
                
                }

                for ( let tx = -radius; tx < radius; tx ++ ) {

                    for ( let ty = -radius; ty < radius; ty ++ ) {

                        if ( tx * tx + ty * ty <= radius2 ) {
                        
                            const x2d = vector.x + tx;
                            const y2d = vector.y + ty;

                            if ( x2d > border.left && x2d < border.right && y2d > border.top && y2d < border.bottom ) {

                                setPixel( x2d | 0, y2d | 0, r, g, b, a  );

                            }

                        }

                    }

                }

            }

            function drawCircleOutline( vector, radius, r, g, b, a, step = 0.05 ) {

                if ( radius === 1 ) {

                    if ( vector.x > border.left && vector.x < border.right && vector.y > border.top && vector.y < border.bottom ) {

                        setPixel( vector.x2d | 0, vector.y2d | 0, r, g, b, a );

                    }

                    return;

                }
                
                if ( vector.x + radius < border.left || vector.x - radius > border.right || vector.y + radius < border.top || vector.y - radius > border.bottom ) {

                    return;
                
                }

                let lx = vector.x + radius * Math.cos( MATHPI2 );
                let ly = vector.y + radius * Math.sin( MATHPI2 );
                
                for ( let theta = 0; theta < MATHPI2 + step; theta += step ) { 

                    const x = vector.x + radius * Math.cos( theta );
                    const y = vector.y + radius * Math.sin( theta );
                    
                    drawLine( lx | 0, ly | 0, x | 0, y | 0, r, g, b, a );
                    
                    lx = x;
                    ly = y;

                }

            }

            /*
            function drawBox( vector, width, height, r, g, b, a ) {

                if ( vector.x + width / 2 < border.left || vector.x - width / 2 > border.right || vector.y + height / 2 < border.top || vector.y - height / 2 > border.bottom ) {

                    return;
                
                }
                
                for ( let y2d = vector.y - height / 2, y2dE = vector.y + height / 2; y2d < y2dE; y2d ++ ) {
                
                    for ( let x2d = vector.x - width / 2, x2dE = vector.x + width / 2; x2d < x2dE; x2d ++ ) {
                    
                        if ( x2d > border.left && x2d < border.right && y2d > border.top && y2d < border.bottom ) {
                        
                            setPixel( x2d | 0, y2d | 0, r, g, b, a );
                        
                        }
                    
                    }

                }

            }

            function drawBoxOutline( vector, width, height, r, g, b, a ) {

                if ( vector.x + width / 2 < border.left || vector.x - width / 2 > border.right || vector.y + height / 2 < border.top || vector.y - height / 2 > border.bottom ) {

                    return;
                
                }

                const topLeftX = vector.x - width / 2;
                const topLeftY = vector.y - height / 2;
                const topRightX = vector.x + width / 2;
                const topRightY = vector.y - height / 2;
                const bottomLeftX = vector.x - width / 2;
                const bottomLeftY = vector.y + height / 2;
                const bottomRightX = vector.x + width / 2;
                const bottomRightY = vector.y + height / 2;
                
                drawLine( topLeftX | 0, topLeftY | 0, topRightX | 0, topRightY | 0, r, g, b, a );
                drawLine( topRightX | 0, topRightY | 0, bottomRightX | 0, bottomRightY | 0, r, g, b, a );
                drawLine( bottomRightX | 0, bottomRightY | 0, bottomLeftX | 0, bottomLeftY | 0, r, g, b, a );
                drawLine( bottomLeftX | 0, bottomLeftY | 0, topLeftX | 0, topLeftY | 0, r, g, b, a );

            }
            */
            //---








            function draw() {

                mouseCursor.position.x = mousePos.x;
                mouseCursor.position.y = mousePos.y;
                mouseCursor.color = { r: 255, g: 255, b: 255, a: 255 };
                
                pathHolder.forEach( ( path, index ) => {
                
                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                        const pathSegment = path.segments[ i ];

                        if ( pathSegment.p0 !== null && pathSegment.p1 !== null ) {

                            const distancep0 = getDistance( mousePos, pathSegment.p0 );
                            const distancep1 = getDistance( mousePos, pathSegment.p1 );

                            if ( distancep0 <= SNAP_TO_DISTANCE ) {

                                mouseCursor.position.x = pathSegment.p0.x;
                                mouseCursor.position.y = pathSegment.p0.y;
                                mouseCursor.color = { r: 0, g: 255, b: 0, a: 255 };
                                
                                //console.log( 'p0: ', pathSegment.p0.x, pathSegment.p0.y, mousePos.x, mousePos.y );

                            } else if ( distancep1 <= SNAP_TO_DISTANCE ) {

                                mouseCursor.position.x = pathSegment.p1.x;
                                mouseCursor.position.y = pathSegment.p1.y;
                                mouseCursor.color = { r: 0, g: 255, b: 0, a: 255 };

                                //console.log( 'p1: ', pathSegment.p1.x, pathSegment.p1.y, mousePos.x, mousePos.y );

                            }

                        }

                    }

                    //---

                    if ( path.startPoint !== null ) {

                        drawCircle( path.startPoint, 5, 0, 255, 0, 255 );
                        drawCircleOutline( path.startPoint, 9, 0, 255, 0, 255 );

                    }

                    if ( path.endPoint !== null ) {

                        drawCircle( path.endPoint, 5, 0, 255, 255, 255 );
                        drawCircleOutline( path.endPoint, 9, 0, 255, 255, 255 );

                    }
                    
                    //---

                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {
            
                        const pathSegment = path.segments[ i ];
                        //if ( i === 0 ) 
                            //console.log( pathSegment );

                        if ( pathSegment.p0 !== null ) {

                            if ( pathSegment.p1 === null && i === l - 1 ) {

                                drawLine( pathSegment.p0.x | 0, pathSegment.p0.y | 0, mouseCursor.position.x | 0, mouseCursor.position.y | 0, 80, 80, 80, 255 );

                            }

                            drawCircle( pathSegment.p0, 3, 255, 0, 0, 255 );

                        }

                        if ( pathSegment.p1 !== null ) {

                            drawLine( pathSegment.p0.x | 0, pathSegment.p0.y | 0, pathSegment.p1.x | 0, pathSegment.p1.y | 0, 200, 0, 0, 255 );

                            drawCircle( pathSegment.p1, 3, 255, 0, 0, 255 );

                            drawCircle( pathSegment.centerPoint, 9, 200, 200, 200, 255 );
                            drawCircleOutline( pathSegment.centerPoint, 9, 255, 0, 0, 255 );

                            
                            // if ( pathSegment.p0.split === true ) {

                            //     drawCircleOutline( pathSegment.p0, 9, 255, 0, 0, 255 );

                            // }

                            // if ( pathSegment.p1.split === true ) {

                            //     drawCircleOutline( pathSegment.p1, 9, 255, 0, 0, 255 );

                            // }
 

                        }
                        /*
                        if ( pathSegment.splitPoints.length > 0 ) {
                        
                            pathSegment.splitPoints.forEach( ( splitPoint, index ) => {
                            
                                drawCircleOutline( splitPoint, 9, 255, 0, 0, 255 );
                            
                            } );
                            
                        }
                        */

                    }
                
                } );
                
                //---

                drawCircleOutline( mouseCursor.position, mouseCursor.diameter, mouseCursor.color.r, mouseCursor.color.g, mouseCursor.color.b, mouseCursor.color.a );

                //---

                //drawBox( rectangle.position, rectangle.dimensions.width, rectangle.dimensions.height, 15, 15, 15, 255 );

                //---

                for ( let i = 0, l = tempPathSegments.length; i < l; i ++ ) {
            
                    const tempPathSegment = tempPathSegments[ i ];

                    if ( tempPathSegment.type === 'line' ) {

                        drawLine( tempPathSegment.p0.x | 0, tempPathSegment.p0.y | 0, tempPathSegment.p1.x | 0, tempPathSegment.p1.y | 0, 0, 200, 0, 255 );

                    } else if ( tempPathSegment.type === 'circ' ) {

                        drawCircleOutline( tempPathSegment.position, tempPathSegment.diameter, tempPathSegment.color.r, tempPathSegment.color.g, tempPathSegment.color.b, tempPathSegment.color.a );

                    }

                    

                }

            }








            //---

            function render( timestamp ) {

                clearImageData();

                //---

                draw();

                //---

                context.putImageData( imageData, 0, 0 );

                //---

                animationFrame = requestAnimFrame( render );

            }

            window.requestAnimFrame = ( function() {

                return  window.requestAnimationFrame       ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame    ||
                        window.msRequestAnimationFrame     ||
                        function( callback ) {
                            window.setTimeout( callback, 1000 / 60 );
                        };

            } )();

            window.cancelAnimFrame = ( function() {

                return  window.cancelAnimationFrame       ||
                        window.mozCancelAnimationFrame;

            } )();

            //---

            init();
            initGUI();

            //---

        } );
        
    </script>

</head>

<body>

    

</body>

</html>