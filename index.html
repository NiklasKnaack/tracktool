<!DOCTYPE html>
<html>

<head>

    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TrackTool</title>
    <script src='./js/dat.gui.min.js'></script>

    <style type='text/css'>

        html, body, div {
            margin: 0;
            padding: 0;
            border: 0;
        }

        body {
            min-height: 100vh;
            overflow: hidden;
            background: radial-gradient(#202020, #000000);
        }

    </style>

    <script>

        document.addEventListener( 'DOMContentLoaded', () => {

            //---

            console.clear();
            console.log( 'Track Tool' );

            //---

            const DEBUG = true;
            let debugElements = [];

            const MATHPI2 = Math.PI * 2;

            const SNAP_TO_DISTANCE = 25;

            const EDITOR_MODE_ENUM = Object.freeze( {
                drawPath: 'drawPath',
                setstartPosition: 'setstartPosition',
                setendPosition: 'setendPosition',
                getPathSegment: 'getPathSegment'
            } );

            let editorMode = EDITOR_MODE_ENUM.drawPath;

            let width = 1024;
            let height = 512;

            const canvas = document.createElement( 'canvas' );
            const context = canvas.getContext( '2d' );

            let animationFrame = null;

            let imageData = null;
            let data = null;

            const border = { left: 1, top: 1, right: width, bottom: height };

            let mouseDown = false;
            let mousePos = { x: 0, y: 0 };
            let mousePosStart = { x: 0, y: 0 };
            let mousePosEnd = { x: 0, y: 0 };
            const mouseCursor = { diameter: 9, color: { r: 255, g: 255, b: 255, a: 255 }, position: { x: 0, y: 0 } };

            let currentPathSegment = null;

            let tempPathSegments = [];

            let pathHolder = [
                { 
                    id: 0,
                    startPoint: { x: 408, y: 864, walkable: true, cost: 0, parentPoint: null, visited: false },
                    endPoint: { x: 220, y: 108, walkable: true, cost: 0, parentPoint: null, visited: false },
                    currentPoint: { x: 408, y: 864, walkable: true, cost: 0, parentPoint: null, visited: false },
                    points: [
                        { x: 408, y: 864, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 551, y: 717, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 547, y: 580, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 658, y: 497, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 741, y: 436, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 741, y: 325, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 552, y: 437, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 403, y: 492, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 404, y: 261, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 567, y: 84, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 220, y: 108, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 245, y: 724, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 241, y: 589, walkable: true, cost: 0, parentPoint: null, visited: false },
                        { x: 87, y: 483, walkable: true, cost: 0, parentPoint: null, visited: false },
                    ],
                    openSet: [
                    ],
                    closedSet: [
                    ],
                    segments: [
                        { index: 0, p0: { x: 408, y: 864, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 551, y: 717, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 479.5, y: 790.5 }, length: 205.08047201037937 },
                        { index: 1, p0: { x: 551, y: 717, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 547, y: 580, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 549, y: 648.5 }, length: 137.05838172107534 },
                        { index: 2, p0: { x: 547, y: 580, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 658, y: 497, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 602.5, y: 538.5 }, length: 138.6001443000692 },
                        { index: 3, p0: { x: 658, y: 497, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 741, y: 436, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 699.5, y: 466.5 }, length: 103.00485425454472 },
                        { index: 4, p0: { x: 741, y: 436, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 741, y: 325, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 741, y: 380.5 }, length: 111 },
                        { index: 5, p0: { x: 658, y: 497, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 552, y: 437, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 605, y: 467 }, length: 121.8031198286809 },
                        { index: 6, p0: { x: 547, y: 580, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 403, y: 492, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 475, y: 536 }, length: 168.7601848778319 },
                        { index: 7, p0: { x: 403, y: 492, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 404, y: 261, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 403.5, y: 376.5 }, length: 231.00216449202375 },
                        { index: 8, p0: { x: 567, y: 84, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 404, y: 261, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 485.5, y: 172.5 }, length: 240.6200324162558 },
                        { index: 9, p0: { x: 220, y: 108, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 404, y: 261, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 312, y: 184.5 }, length: 239.30106560565082 },
                        { index: 10, p0: { x: 408, y: 864, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 245, y: 724, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 326.5, y: 794 }, length: 214.8697279748825 },
                        { index: 11, p0: { x: 245, y: 724, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 241, y: 589, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 243, y: 656.5 }, length: 135.05924625881784 },
                        { index: 12, p0: { x: 241, y: 589, walkable: true, cost: 0, parentPoint: null, visited: false }, p1: { x: 87, y: 483, walkable: true, cost: 0, parentPoint: null, visited: false }, centerPoint: { x: 164, y: 536 }, length: 186.9545399288287 },
                    ]
                }
            ];

            if ( DEBUG === true ) {

                rebuildDebugElements();

            }

            //---

            function initGUI() {
            
                const _drawPath = () => {
                
                    editorMode = EDITOR_MODE_ENUM.drawPath;
                
                }
                
                const _setstartPosition = () => {
                
                    editorMode = EDITOR_MODE_ENUM.setstartPosition;
                
                }
                
                const _setendPosition = () => {
                
                    editorMode = EDITOR_MODE_ENUM.setendPosition;
                
                }

                const _getPathSegment = () => {

                    editorMode = EDITOR_MODE_ENUM.getPathSegment;

                }
                
                const _clearAll = () => {

                    const pathIndex = 0;

                    currentPathSegment = null;
                    pathHolder[ pathIndex ] = { 
                        id: pathIndex,
                        startPoint: null,
                        endPoint: null,
                        currentPoint: null,
                        points: [],
                        openSet: [],
                        closedSet: [],
                        segments: [] 
                    }

                    removeDebugElements();
                
                }

                const _logPath = () => {

                    const pathIndex = 0;

                    const path = pathHolder[ pathIndex ];

                    let output = '';

                    output += 'id: ' + pathIndex + ',\n';
                    output += 'startPoint: ' + '{ x: ' + path.startPoint.x + ', y: ' + path.startPoint.y + ', walkable: ' + path.startPoint.walkable + ', cost: ' + path.startPoint.cost + '' + ', parentPoint: ' + 'null' + ', visited: ' + path.startPoint.visited + ' },' + '\n';
                    output += 'endPoint: ' + '{ x: ' + path.endPoint.x + ', y: ' + path.endPoint.y + ', walkable: ' + path.endPoint.walkable + ', cost: ' + path.endPoint.cost + '' + ', parentPoint: ' + 'null' + ', visited: ' + path.startPoint.visited + ' },' + '\n';
                    output += 'currentPoint: ' + '{ x: ' + path.currentPoint.x + ', y: ' + path.currentPoint.y + ', walkable: ' + path.currentPoint.walkable + ', cost: ' + path.currentPoint.cost + '' + ', parentPoint: ' + 'null' + ', visited: ' + path.startPoint.visited + ' },' + '\n';
                    output += 'points: [' + '\n';

                    for ( let i = 0, l = path.points.length; i < l; i ++ ) {

                        const point = path.points[ i ];

                        output += '    { x: ' + point.x + ', y: ' + point.y + ', walkable: ' + point.walkable + ', cost: ' + point.cost + '' + ', parentPoint: ' + 'null' + ', visited: ' + path.startPoint.visited + ' }';

                        if ( i < l ) {

                            output += ',\n';

                        } else {

                            output += '\n';

                        }

                    }

                    output += '],' + '\n';
                    output += 'openSet: [' + '\n';

                    for ( let i = 0, l = path.openSet.length; i < l; i ++ ) {

                        const point = path.openSet[ i ];

                        output += '    { x: ' + point.x + ', y: ' + point.y + ', walkable: ' + point.walkable + ', cost: ' + point.cost + '' + ', parentPoint: ' + 'null' + ', visited: ' + path.startPoint.visited + ' }';

                        if ( i < l ) {

                            output += ',\n';

                        } else {

                            output += '\n';

                        }

                    }

                    output += '],' + '\n';
                    output += 'closedSet: [' + '\n';

                    for ( let i = 0, l = path.closedSet.length; i < l; i ++ ) {

                        const point = path.closedSet[ i ];

                        output += '    { x: ' + point.x + ', y: ' + point.y + ', walkable: ' + point.walkable + ', cost: ' + point.cost + '' + ', parentPoint: ' + 'null' + ', visited: ' + path.startPoint.visited + ' }';

                        if ( i < l ) {

                            output += ',\n';

                        } else {

                            output += '\n';

                        }

                    }

                    output += '],' + '\n';
                    output += 'segments: [' + '\n';

                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                        const pathSegment = path.segments[ i ];

                        console.log(pathSegment);

                        output += '    { index: ' + pathSegment.index + ', p0: ' + '{ x: ' + pathSegment.p0.x + ', y: ' + pathSegment.p0.y + ', walkable: ' + pathSegment.p0.walkable + ', cost: ' + pathSegment.p0.cost + '' + ', parentPoint: ' + 'null' + ', visited: ' + pathSegment.p0.visited + ' }' + ', p1: ' + '{ x: ' + pathSegment.p1.x + ', y: ' + pathSegment.p1.y + ', walkable: ' + pathSegment.p1.walkable + ', cost: ' + pathSegment.p1.cost + '' + ', parentPoint: ' + 'null' + ', visited: ' + pathSegment.p1.visited + ' }' + ', centerPoint: ' + '{ x: ' + pathSegment.centerPoint.x + ', y: ' + pathSegment.centerPoint.y + ' }' + ', length: ' + pathSegment.length + ' }';

                        if ( i < l ) {

                            output += ',\n';

                        } else {

                            output += '\n';

                        }

                    }

                    output += ']' + '\n';

                    console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );
                    console.log( output );
                    console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );

                }

                const _findPath = () => {
                    
                    findPath();
                
                }
                
                const _linkTo = () => {
                
                    window.open( 'https://twitter.com/niklaswebdev', '_blank' );
                
                }
                
                //---
                
                const guiSetting = {
                        
                    'Draw Path': _drawPath,
                    'Set Start Point': _setstartPosition,
                    'Set End Point': _setendPosition,
                    'Clear All': _clearAll,
                    'Get PathSegment': _getPathSegment,
                    'Log Path': _logPath,
                    'Find Path': _findPath,
                    '@niklaswebdev': _linkTo
                    
                }

                const gui = new dat.GUI();

                const folderEdit = gui.addFolder( 'Edit' );

                folderEdit.open();
                folderEdit.add( guiSetting, 'Draw Path' );
                folderEdit.add( guiSetting, 'Set Start Point' );
                folderEdit.add( guiSetting, 'Set End Point' );
                folderEdit.add( guiSetting, 'Clear All' );

                const folderAnalyze = gui.addFolder( 'Analyze' );

                folderAnalyze.open();
                folderAnalyze.add( guiSetting, 'Get PathSegment' );
                folderAnalyze.add( guiSetting, 'Log Path' );
                folderAnalyze.add( guiSetting, 'Find Path' );

                const folderContact = gui.addFolder( 'Contact' );

                folderContact.add( guiSetting, '@niklaswebdev' );

                //gui.close();

            }

            //---

            function init() {
                
                canvas.addEventListener( 'mousedown', mouseDownHandler, false );
                //canvas.addEventListener( 'mouseup', mouseUpHandler, false );
                canvas.addEventListener( 'mousemove', mouseMoveHandler, false );

                document.body.appendChild( canvas );

                window.addEventListener( 'resize', onResize, false );

                restart();

            }

            function onResize( event ) {
                
                restart();

            }

            function restart() {

                width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                canvas.width = width;
                canvas.height = height;

                imageData = context.getImageData( 0, 0, width, height );
                data = imageData.data;
                
                //---

                border.right = width;
                border.bottom = height;

                //---
                
                if ( animationFrame !== null ) {
                
                    cancelAnimFrame( animationFrame );
                
                }
                
                animationFrame = requestAnimFrame( render );

            }

            //---








            function getNextPathSegmentsByPoint( point, pathSegments ) {

                const pathSegmentsFound = [];

                //for ( let i = pathSegments.length - 1, l = -1; i > l; i -- ) {
                for ( let i = 0, l = pathSegments.length; i < l; i ++ ) {

                    const pathSegment = pathSegments[ i ];

                    if ( point.x === pathSegment.p0.x && point.y === pathSegment.p0.y ) {

                        pathSegmentsFound.push( pathSegment );
                    
                    } else if ( point.x === pathSegment.p1.x && point.y === pathSegment.p1.y ) {

                        pathSegmentsFound.push( pathSegment );
                    
                    }

                }

                return pathSegmentsFound;

            }

            function getNextPointsByCurrentPointAndNextPathSegments( point, nextPathSegments ) {

                const pointsFound = [];

                for ( let i = 0, l = nextPathSegments.length; i < l; i ++ ) {

                    const nextPathSegment = nextPathSegments[ i ];

                    if ( point.x === nextPathSegment.p0.x && point.y === nextPathSegment.p0.y ) {

                        pointsFound.push( nextPathSegment.p1 );

                    } else if ( point.x === nextPathSegment.p1.x && point.y === nextPathSegment.p1.y ) {

                        pointsFound.push( nextPathSegment.p0 );

                    }

                }

                return pointsFound;

            }

            function getPointByPosition( position ) {

                const pathIndex = 0;

                const path = pathHolder[ pathIndex ];

                let point = null;

                for ( let i = 0, l = path.points.length; i < l; i ++ ) {

                    const p = path.points[ i ];

                    if ( p.x === position.x && p.y === position.y ) {

                        point = p;

                    }
                }

                return point;

            }

            function findPath() {

                console.log( '\n\n\n\n\n\n\nfindPath()' );

                tempPathSegments = [];

                //---

                const pathIndex = 0;

                const path = pathHolder[ pathIndex ];

                path.openSet = [];
                path.closedSet = [];

                for ( let i = 0, l = path.points.length; i < l; i ++ ) {

                    const point = path.points[ i ];

                    point.cost = Infinity;
                    point.parentPoint = null;
                    point.visited = false;

                }

                path.currentPoint = getPointByPosition( path.startPoint );
                path.currentPoint.cost = 0;

                path.openSet.push( path.currentPoint );


                let iteration = 0;

                //console.log( 'currentPoint: ', path.currentPoint.x, path.currentPoint.y );

                while ( path.openSet.length > 0 && iteration < 111 ) {

                    console.log( '______________________________________', path.openSet.length );

                    path.currentPoint = path.openSet.find( point => point.cost === Math.min( ...path.openSet.map( nextPoint => nextPoint.cost ) ) );
                    path.currentPoint.visited = true;

                    // for ( let i = 0, l = path.openSet.length; i < l; i ++ ) {

                    //     console.log( '--->>> ', path.openSet[ i ].x, path.openSet[ i ].y, path.openSet[ i ].visited, path.openSet[ i ].cost);

                    // }

                    console.log( path.currentPoint );
                    console.log( 'path.currentPoint: ', path.currentPoint.x, path.currentPoint.y, path.currentPoint.visited );
                    //console.log( path.endPoint );

                    //---

                    const nextPathSegments = getNextPathSegmentsByPoint( path.currentPoint, path.segments );

                    if ( nextPathSegments.length > 0 ) {

                        const nextPoints = getNextPointsByCurrentPointAndNextPathSegments( path.currentPoint, nextPathSegments );

                        console.log( '--_>>> ', nextPoints.length );

                        for ( let i = 0, l = nextPoints.length; i < l; i ++ ) {

                            const nextPoint = getPointByPosition( nextPoints[ i ] );

                            if ( nextPoint.visited === false && nextPoint.walkable === true ) {

                                const nextDistance = path.currentPoint.cost + getDistance( nextPoint, path.currentPoint );

                                if ( nextDistance < nextPoint.cost ) {

                                    nextPoint.parentPoint = path.currentPoint;

                                    nextPoint.cost = nextDistance;

                                } 

                                path.openSet.push( nextPoint );

                            }

                        }

                    } 

                    path.openSet.splice( path.openSet.findIndex( ( point ) => point.x === path.currentPoint.x && point.y === path.currentPoint.y ), 1 );

                    iteration++;

                }


                //console.log( 'path.openSet, ', path.openSet );
                //console.log( 'path.endPoint.parentPoint, ', path.endPoint.parentPoint );
                //console.log( 'path.endPoint.parentPoint, ', getPointByPosition( path.endPoint ).parentPoint );



                if ( getPointByPosition( path.endPoint ).parentPoint !== null ) {

                    console.log( 'FOUND END' );

                    const pathToEnd = [];

                    let currentPoint = getPointByPosition( path.endPoint );

                    while ( currentPoint !== null ) {

                        pathToEnd.push( currentPoint );

                        currentPoint = currentPoint.parentPoint;

                    }

                    pathToEnd.reverse();

                    for ( let i = 0, l = pathToEnd.length - 1; i < l; i ++ ) {

                        const point0 = pathToEnd[ i ];
                        const point1 = pathToEnd[ i + 1 ];

                        tempPathSegments.push( { type: 'line', p0: { x: point0.x, y: point0.y }, p1: { x: point1.x, y: point1.y } } );
                        tempPathSegments.push( { type: 'circ', position: { x: point0.x, y: point0.y }, diameter: 15, color: { r: 255, g: 0, b: 255, a: 255 }  } );
                        tempPathSegments.push( { type: 'circ', position: { x: point1.x, y: point1.y }, diameter: 15, color: { r: 255, g: 0, b: 255, a: 255 }  } );

                    }

                }

            }

            //---

            function getPathSegmentPointsByPosition( position ) {

                const pathIndex = 0;

                const path = pathHolder[ pathIndex ];

                const result = [];

                for ( let i = 0, l = path.segments.length; i < l; i ++ ) {
            
                    const pathSegment = path.segments[ i ];

                    if ( pathSegment.p0.x === position.x && pathSegment.p0.y === position.y ) {

                        result.push( pathSegment.p0 );

                    }

                    if ( pathSegment.p1.x === position.x && pathSegment.p1.y === position.y ) {

                        result.push( pathSegment.p1 );

                    }

                }

                return result;

            }

            function getPathSegementPoint( position, walkable = true, cost = 0, hCost = 0, parentPoint = null ) {

                const point = {

                    x: position.x,
                    y: position.y,
                    walkable: walkable,
                    cost: cost,
                    hCost: hCost,
                    get fCost() {

                        return this.cost + this.hCost;

                    },
                    parentPoint: parentPoint,
                    visited: false

                };

                return point;

            }

            function addPathSegment( position ) {

                const path = pathHolder[ 0 ];
                
                if ( currentPathSegment === null ) {

                    const pathSegmentPointNew = getPathSegementPoint( position );
                    const pathSegmentPointArray = isObjectInArray( path.points, pathSegmentPointNew );
                    const pathSegmentPoint = typeof pathSegmentPointArray === 'undefined' ? pathSegmentPointNew : pathSegmentPointArray;

                    if ( typeof pathSegmentPointArray === 'undefined' ) {

                        path.points.push( pathSegmentPoint );

                    }

                    currentPathSegment = {};
                    currentPathSegment.index = path.segments.length;
                    currentPathSegment.p0 = pathSegmentPoint;//getPathSegementPoint( position );
                    currentPathSegment.p1 = null;
                    //currentPathSegment.startPosition = null;
                    //currentPathSegment.endPosition = null;
                    //currentPathSegment.sorted = false;

                    
                    

                    // const pathSegmentPointsWithSamePosition = getPathSegmentPointsByPosition( currentPathSegment.p0 );

                    // if ( pathSegmentPointsWithSamePosition.length > 1 ) {

                        // pathSegmentPointsWithSamePosition.push( currentPathSegment.p0 );
                        
                        // for ( let i = 0, l = pathSegmentPointsWithSamePosition.length; i < l; i++ ) {

                        //     pathSegmentPointsWithSamePosition[ i ].split = true;

                        // }

                    // }

                    path.segments.push( currentPathSegment );

                    if ( DEBUG === true ) {

                        addDebugElement( position.x, position.y, position.x.toString() + ', ' + position.y.toString(), 'white', 0, 9, null );

                        //addDebugElement( position.x, position.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, currentPathSegment.index );

                    } 
                
                } else {

                    const pathSegmentPointNew = getPathSegementPoint( position );
                    const pathSegmentPointArray = isObjectInArray( path.points, pathSegmentPointNew );
                    const pathSegmentPoint = typeof pathSegmentPointArray === 'undefined' ? pathSegmentPointNew : pathSegmentPointArray;

                    if ( typeof pathSegmentPointArray === 'undefined' ) {

                        path.points.push( pathSegmentPoint );

                    }

                    currentPathSegment.p1 = pathSegmentPoint;//getPathSegementPoint( position );
                    currentPathSegment.length = getDistance( currentPathSegment.p0, currentPathSegment.p1 );
                    currentPathSegment.centerPoint = getPathSegmentCenter( currentPathSegment );

                    // const pathSegmentPointsWithSamePosition = getPathSegmentPointsByPosition( currentPathSegment.p1 );

                    // if ( pathSegmentPointsWithSamePosition.length > 2 ) {

                        // pathSegmentPointsWithSamePosition.push( currentPathSegment.p1 );

                        // for ( let i = 0, l = pathSegmentPointsWithSamePosition.length; i < l; i++ ) {

                        //     pathSegmentPointsWithSamePosition[ i ].split = true;

                        // }

                    // }

                    if ( DEBUG === true ) {

                        addDebugElement( position.x, position.y, position.x.toString() + ', ' + position.y.toString(), 'white', 0, 9, null );
                        addDebugElement( currentPathSegment.centerPoint.x, currentPathSegment.centerPoint.y, currentPathSegment.index.toString(), 'black', -3, -5, null );
                        
                        addDebugElement( currentPathSegment.centerPoint.x, currentPathSegment.centerPoint.y, currentPathSegment.length.toFixed( 2 ).toString(), 'white', 10, -5, null );

                        //addDebugElement( position.x, position.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, currentPathSegment.index );

                    } 

                    currentPathSegment = null;

                    //---

                    //sortPath( path );
                
                }

            }

            //---

            function addStartPointToPath( pathIndex, position ) {

                const path = pathHolder[ pathIndex ];

                path.startPoint = getPathSegmentPointsByPosition( position )[ 0 ];

                console.log( 'path.startPoint: ', path.startPoint );

                path.currentPoint = path.startPoint;

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }

            function addEndPointToPath( pathIndex, position ) {

                const path = pathHolder[ pathIndex ];

                path.endPoint = getPathSegmentPointsByPosition( position )[ 0 ];

                console.log( 'path.endPoint: ', path.endPoint );

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }

            //---

            function rebuildDebugElements() {

                removeDebugElements();

                //---

                const path = pathHolder[ 0 ];

                if ( path.startPoint !== null ) {

                    addDebugElement( path.startPoint.x, path.startPoint.y, 'START', 'white', -15, -25, null );

                }

                if ( path.endPoint !== null ) {

                    addDebugElement( path.endPoint.x, path.endPoint.y, 'END', 'white', -15, -25, null );

                }

                path.segments.forEach( ( pathSegment, index ) => {

                    if ( index < path.segments.length - 1 ) {

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, pathSegment.p0.x.toString() + ', ' + pathSegment.p0.y.toString(), 'white', 0, 9, null );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, pathSegment.p1.x.toString() + ', ' + pathSegment.p1.y.toString(), 'white', 0, 9, null );

                        //addDebugElement( pathSegment.p0.x, pathSegment.p0.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );
                        //addDebugElement( pathSegment.p1.x, pathSegment.p1.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );

                    } else {

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, pathSegment.p0.x.toString() + ', ' + pathSegment.p0.y.toString(), 'white', 0, 9, null );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, pathSegment.p1.x.toString() + ', ' + pathSegment.p1.y.toString(), 'white', 0, 9, null );

                        //addDebugElement( pathSegment.p0.x, pathSegment.p0.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );
                        //addDebugElement( pathSegment.p1.x, pathSegment.p1.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );

                    }

                    addDebugElement( pathSegment.centerPoint.x, pathSegment.centerPoint.y, pathSegment.index.toString(), 'black', -3, -5, null );
                    addDebugElement( pathSegment.centerPoint.x, pathSegment.centerPoint.y, pathSegment.length.toFixed( 2 ).toString(), 'white', 10, -5, null );

                } );

            }

            function removeDebugElements() {

                debugElements.forEach( ( debugElement, index ) => {

                    document.body.removeChild( debugElement );

                } );

                debugElements = [];

            }

            function addDebugElement( x, y, message, color = 'white', offsetX = 0, offsetY = 0, className = null ) {

                const debugElement = document.createElement( 'div' );

                debugElement.style.position = 'absolute';
                debugElement.style.left = ( x + offsetX ).toString() + 'px';
                debugElement.style.top = ( y + offsetY ).toString() + 'px';
                debugElement.style.color = color;
                debugElement.style.fontSize = '8pt';
                debugElement.style.pointerEvents = 'none';

                if ( className === null ) {

                    debugElement.className = 'debug-' + ( new Date().getTime() + debugElements.length ).toString();

                } else {

                    debugElement.className = 'debug-' + className.toString();

                }

                debugElement.innerHTML = message;

                document.body.appendChild( debugElement );

                debugElements.push( debugElement );

            }

            //---

            function getDistance( p1, p2 ) {

                const a = p1.x - p2.x;
                const b = p1.y - p2.y;

                return Math.sqrt( a * a + b * b );
            
            }

            function getPathSegmentCenter( pathSegment ) {

                const x = ( pathSegment.p0.x + pathSegment.p1.x ) / 2;
                const y = ( pathSegment.p0.y + pathSegment.p1.y ) / 2;
            
                return { x: x, y: y };
            
            }

            function signedDistanceToLine( p, p0X, p0Y, p1X, p1Y ) {

                const p0p1X = p0X - p1X;
                const p0p1Y = p0Y - p1Y;

                const l2 = p0p1X * p0p1X + p0p1Y * p0p1Y;

                const pp0X = p.x - p0X;
                const pp0Y = p.y - p0Y;

                if ( l2 === 0 ) {

                    return pp0X * pp0X + pp0Y * pp0Y;

                }

                const p1p0X = p1X - p0X;
                const p1p0Y = p1Y - p0Y;

                const t = clamp( ( pp0X * p1p0X + pp0Y * p1p0Y ) / l2, 0, 1 );

                const ptX = p0X + t * p1p0X;
                const ptY = p0Y + t * p1p0Y;

                const pX = p.x - ptX;
                const pY = p.y - ptY;

                return Math.sqrt( pX * pX + pY * pY );

            }

            //---

            function clamp( val, min, max ) {

                return Math.min( Math.max( min, val ), max );

            }

            //---

            function isObjectInArray( array, compareObject ) {

                //return typeof array.find( ( point ) => point.x === compareObject.x && point.y === compareObject.y ) === 'undefined' ? false : true;
                return array.find( ( point ) => point.x === compareObject.x && point.y === compareObject.y );

            }

            //---






            //---

            function mouseDownHandler( event ) {

                // editorMode = EDITOR_MODE_ENUM.drawPath;

                if ( editorMode === EDITOR_MODE_ENUM.drawPath ) {

                    addPathSegment( mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.setstartPosition ) {

                    //addStartPositionToPathSegment( mouseCursor.position );

                    addStartPointToPath( 0, mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.setendPosition ) {

                    //addEndPositionToPathSegment( mouseCursor.position );

                    addEndPointToPath( 0, mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.getPathSegment ) {

                    //addEndPositionToPathSegment( mouseCursor.position );

                }

            }

            function mouseUpHandler( event ) {

                //mouseDown = false;
            
                //mousePosEnd = getMousePos( canvas, event );
            
                //endLineSegment( mousePosEnd );

            }

            function mouseMoveHandler( event ) {

                mousePos = getMousePos( canvas, event );

                if ( editorMode === EDITOR_MODE_ENUM.getPathSegment ) {

                    tempPathSegments = [];

                    //---

                    let distanceTotal = Infinity;
                    let indexSave = -1;

                    pathHolder.forEach( ( path, index ) => {
                
                        for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                            const pathSegment = path.segments[ i ];

                            const distanceToPathSegment = signedDistanceToLine( mousePos, pathSegment.p0.x, pathSegment.p0.y, pathSegment.p1.x, pathSegment.p1.y );

                            if ( distanceToPathSegment < distanceTotal ) {

                                distanceTotal = distanceToPathSegment;

                                indexSave = i;

                            }

                        }

                    } );
                    
                    if ( indexSave > -1 && distanceTotal <= SNAP_TO_DISTANCE ) {

                        const pathSegment = pathHolder[ 0 ].segments[ indexSave ];

                        // console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );
                        // console.log( 'PATH ID: ', pathSegment.index );
                        // console.log( 'p0: ', pathSegment.p0 );
                        // console.log( 'p1: ', pathSegment.p1 );
                        // console.log( 'startPosition: ', pathSegment.startPosition );
                        // console.log( 'endPosition: ', pathSegment.endPosition );
                        // console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );

                        tempPathSegments.push( { type: 'line', p0: { x: pathSegment.p0.x, y: pathSegment.p0.y }, p1: { x: pathSegment.p1.x, y: pathSegment.p1.y } } );
                        tempPathSegments.push( { type: 'circ', position: { x: pathSegment.p0.x, y: pathSegment.p0.y }, diameter: 20, color: { r: 255, g: 0, b: 255, a: 255 }  } );
                        tempPathSegments.push( { type: 'circ', position: { x: pathSegment.p1.x, y: pathSegment.p1.y }, diameter: 20, color: { r: 0, g: 255, b: 255, a: 255 }  } );

                    }

                }

            }

            function getMousePos( canvas, event ) {

                const rect = canvas.getBoundingClientRect();

                return { x: event.clientX - rect.left, y: event.clientY - rect.top };

            }

            //---

            function clearImageData() {

                for ( let i = 0, l = data.length; i < l; i += 4 ) {

                    data[ i ] = 0;
                    data[ i + 1 ] = 0;
                    data[ i + 2 ] = 0;
                    data[ i + 3 ] = 0;

                }

            }

            function setPixel( x, y, r, g, b, a ) {

                const i = ( x + y * imageData.width ) * 4;

                data[ i ] = r;
                data[ i + 1 ] = g;
                data[ i + 2 ] = b;
                data[ i + 3 ] = a;

            }

            //---

            function drawLine( x1, y1, x2, y2, r, g, b, a ) {

                const dx = Math.abs( x2 - x1 );
                const dy = Math.abs( y2 - y1 );

                const sx = ( x1 < x2 ) ? 1 : -1;
                const sy = ( y1 < y2 ) ? 1 : -1;

                let err = dx - dy;

                let lx = x1;
                let ly = y1;    

                while ( true ) {

                    if ( lx > 0 && lx < width && ly > 0 && ly < height ) {

                        setPixel( lx, ly, r, g, b, a );

                    }

                    if ( ( lx === x2 ) && ( ly === y2 ) ) {
                    
                        break;
                    
                    }

                    const e2 = 2 * err;

                    if ( e2 > -dx ) { 

                        err -= dy; 
                        lx += sx; 

                    }

                    if ( e2 < dy ) { 

                        err += dx; 
                        ly += sy; 

                    }

                }

            }

            function drawCircle( vector, radius, r, g, b, a ) {
                
                const radius2 = radius * radius;

                if ( radius === 1 ) {

                    if ( vector.x > border.left && vector.x < border.right && vector.y > border.top && vector.y < border.bottom ) {

                        setPixel( vector.x2d | 0, vector.y2d | 0, r, g, b, a );

                    }

                    return;

                }
                
                if ( vector.x + radius < border.left || vector.x - radius > border.right || vector.y + radius < border.top || vector.y - radius > border.bottom ) {

                    return;
                
                }

                for ( let tx = -radius; tx < radius; tx ++ ) {

                    for ( let ty = -radius; ty < radius; ty ++ ) {

                        if ( tx * tx + ty * ty <= radius2 ) {
                        
                            const x2d = vector.x + tx;
                            const y2d = vector.y + ty;

                            if ( x2d > border.left && x2d < border.right && y2d > border.top && y2d < border.bottom ) {

                                setPixel( x2d | 0, y2d | 0, r, g, b, a  );

                            }

                        }

                    }

                }

            }

            function drawCircleOutline( vector, radius, r, g, b, a, step = 0.05 ) {

                if ( radius === 1 ) {

                    if ( vector.x > border.left && vector.x < border.right && vector.y > border.top && vector.y < border.bottom ) {

                        setPixel( vector.x2d | 0, vector.y2d | 0, r, g, b, a );

                    }

                    return;

                }
                
                if ( vector.x + radius < border.left || vector.x - radius > border.right || vector.y + radius < border.top || vector.y - radius > border.bottom ) {

                    return;
                
                }

                let lx = vector.x + radius * Math.cos( MATHPI2 );
                let ly = vector.y + radius * Math.sin( MATHPI2 );
                
                for ( let theta = 0; theta < MATHPI2 + step; theta += step ) { 

                    const x = vector.x + radius * Math.cos( theta );
                    const y = vector.y + radius * Math.sin( theta );
                    
                    drawLine( lx | 0, ly | 0, x | 0, y | 0, r, g, b, a );
                    
                    lx = x;
                    ly = y;

                }

            }

            /*
            function drawBox( vector, width, height, r, g, b, a ) {

                if ( vector.x + width / 2 < border.left || vector.x - width / 2 > border.right || vector.y + height / 2 < border.top || vector.y - height / 2 > border.bottom ) {

                    return;
                
                }
                
                for ( let y2d = vector.y - height / 2, y2dE = vector.y + height / 2; y2d < y2dE; y2d ++ ) {
                
                    for ( let x2d = vector.x - width / 2, x2dE = vector.x + width / 2; x2d < x2dE; x2d ++ ) {
                    
                        if ( x2d > border.left && x2d < border.right && y2d > border.top && y2d < border.bottom ) {
                        
                            setPixel( x2d | 0, y2d | 0, r, g, b, a );
                        
                        }
                    
                    }

                }

            }

            function drawBoxOutline( vector, width, height, r, g, b, a ) {

                if ( vector.x + width / 2 < border.left || vector.x - width / 2 > border.right || vector.y + height / 2 < border.top || vector.y - height / 2 > border.bottom ) {

                    return;
                
                }

                const topLeftX = vector.x - width / 2;
                const topLeftY = vector.y - height / 2;
                const topRightX = vector.x + width / 2;
                const topRightY = vector.y - height / 2;
                const bottomLeftX = vector.x - width / 2;
                const bottomLeftY = vector.y + height / 2;
                const bottomRightX = vector.x + width / 2;
                const bottomRightY = vector.y + height / 2;
                
                drawLine( topLeftX | 0, topLeftY | 0, topRightX | 0, topRightY | 0, r, g, b, a );
                drawLine( topRightX | 0, topRightY | 0, bottomRightX | 0, bottomRightY | 0, r, g, b, a );
                drawLine( bottomRightX | 0, bottomRightY | 0, bottomLeftX | 0, bottomLeftY | 0, r, g, b, a );
                drawLine( bottomLeftX | 0, bottomLeftY | 0, topLeftX | 0, topLeftY | 0, r, g, b, a );

            }
            */
            //---








            function draw() {

                mouseCursor.position.x = mousePos.x;
                mouseCursor.position.y = mousePos.y;
                mouseCursor.color = { r: 255, g: 255, b: 255, a: 255 };
                
                pathHolder.forEach( ( path, index ) => {
                
                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                        const pathSegment = path.segments[ i ];

                        if ( pathSegment.p0 !== null && pathSegment.p1 !== null ) {

                            const distancep0 = getDistance( mousePos, pathSegment.p0 );
                            const distancep1 = getDistance( mousePos, pathSegment.p1 );

                            if ( distancep0 <= SNAP_TO_DISTANCE ) {

                                mouseCursor.position.x = pathSegment.p0.x;
                                mouseCursor.position.y = pathSegment.p0.y;
                                mouseCursor.color = { r: 0, g: 255, b: 0, a: 255 };
                                
                                //console.log( 'p0: ', pathSegment.p0.x, pathSegment.p0.y, mousePos.x, mousePos.y );

                            } else if ( distancep1 <= SNAP_TO_DISTANCE ) {

                                mouseCursor.position.x = pathSegment.p1.x;
                                mouseCursor.position.y = pathSegment.p1.y;
                                mouseCursor.color = { r: 0, g: 255, b: 0, a: 255 };

                                //console.log( 'p1: ', pathSegment.p1.x, pathSegment.p1.y, mousePos.x, mousePos.y );

                            }

                        }

                    }

                    //---

                    if ( path.startPoint !== null ) {

                        drawCircle( path.startPoint, 5, 0, 255, 0, 255 );
                        drawCircleOutline( path.startPoint, 9, 0, 255, 0, 255 );

                    }

                    if ( path.endPoint !== null ) {

                        drawCircle( path.endPoint, 5, 0, 255, 255, 255 );
                        drawCircleOutline( path.endPoint, 9, 0, 255, 255, 255 );

                    }
                    
                    //---

                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {
            
                        const pathSegment = path.segments[ i ];
                        //if ( i === 0 ) 
                            //console.log( pathSegment );

                        if ( pathSegment.p0 !== null ) {

                            if ( pathSegment.p1 === null && i === l - 1 ) {

                                drawLine( pathSegment.p0.x | 0, pathSegment.p0.y | 0, mouseCursor.position.x | 0, mouseCursor.position.y | 0, 80, 80, 80, 255 );

                            }

                            drawCircle( pathSegment.p0, 3, 255, 0, 0, 255 );

                        }

                        if ( pathSegment.p1 !== null ) {

                            drawLine( pathSegment.p0.x | 0, pathSegment.p0.y | 0, pathSegment.p1.x | 0, pathSegment.p1.y | 0, 200, 0, 0, 255 );

                            drawCircle( pathSegment.p1, 3, 255, 0, 0, 255 );

                            drawCircle( pathSegment.centerPoint, 9, 200, 200, 200, 255 );
                            drawCircleOutline( pathSegment.centerPoint, 9, 255, 0, 0, 255 );

                            
                            // if ( pathSegment.p0.split === true ) {

                            //     drawCircleOutline( pathSegment.p0, 9, 255, 0, 0, 255 );

                            // }

                            // if ( pathSegment.p1.split === true ) {

                            //     drawCircleOutline( pathSegment.p1, 9, 255, 0, 0, 255 );

                            // }
 

                        }

                    }
                
                } );
                
                //---

                drawCircleOutline( mouseCursor.position, mouseCursor.diameter, mouseCursor.color.r, mouseCursor.color.g, mouseCursor.color.b, mouseCursor.color.a );

                //---

                //drawBox( rectangle.position, rectangle.dimensions.width, rectangle.dimensions.height, 15, 15, 15, 255 );

                //---

                for ( let i = 0, l = tempPathSegments.length; i < l; i ++ ) {
            
                    const tempPathSegment = tempPathSegments[ i ];

                    if ( tempPathSegment.type === 'line' ) {

                        drawLine( tempPathSegment.p0.x | 0, tempPathSegment.p0.y | 0, tempPathSegment.p1.x | 0, tempPathSegment.p1.y | 0, 0, 200, 0, 255 );

                    } else if ( tempPathSegment.type === 'circ' ) {

                        drawCircleOutline( tempPathSegment.position, tempPathSegment.diameter, tempPathSegment.color.r, tempPathSegment.color.g, tempPathSegment.color.b, tempPathSegment.color.a );

                    }

                }

            }

            //---

            function render( timestamp ) {

                clearImageData();

                //---

                draw();

                //---

                context.putImageData( imageData, 0, 0 );

                //---

                animationFrame = requestAnimFrame( render );

            }

            window.requestAnimFrame = ( function() {

                return  window.requestAnimationFrame       ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame    ||
                        window.msRequestAnimationFrame     ||
                        function( callback ) {
                            window.setTimeout( callback, 1000 / 60 );
                        };

            } )();

            window.cancelAnimFrame = ( function() {

                return  window.cancelAnimationFrame       ||
                        window.mozCancelAnimationFrame;

            } )();

            //---

            init();
            initGUI();

            //---

        } );
        
    </script>

</head>

<body>

    

</body>

</html>