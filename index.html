<!DOCTYPE html>
<html>

<head>

    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TrackTool</title>
    <script src='./js/dat.gui.min.js'></script>

    <style type='text/css'>

        html, body, div {
            margin: 0;
            padding: 0;
            border: 0;
        }

        body {
            min-height: 100vh;
            overflow: hidden;
            background: radial-gradient(#202020, #000000);
        }

    </style>

    <script>

        document.addEventListener( 'DOMContentLoaded', () => {

            //---

            console.clear();
            console.log( 'Track Tool' );

            //---

            const DEBUG = true;
            let debugElements = [];

            const MATHPI2 = Math.PI * 2;

            const SNAP_TO_DISTANCE = 25;

            const EDITOR_MODE_ENUM = Object.freeze( {
                drawPath: 'drawPath',
                setstartPosition: 'setstartPosition',
                setendPosition: 'setendPosition',
                getPathSegment: 'getPathSegment'
            } );

            let editorMode = EDITOR_MODE_ENUM.drawPath;

            let width = 1024;
            let height = 512;

            const canvas = document.createElement( 'canvas' );
            const context = canvas.getContext( '2d' );

            let animationFrame = null;

            let imageData = null;
            let data = null;

            const border = { left: 1, top: 1, right: width, bottom: height };

            let mouseDown = false;
            let mousePos = { x: 0, y: 0 };
            let mousePosStart = { x: 0, y: 0 };
            let mousePosEnd = { x: 0, y: 0 };
            const mouseCursor = { diameter: 9, color: { r: 255, g: 255, b: 255, a: 255 }, position: { x: 0, y: 0 } };

            let currentPathSegment = null;

            let tempPathSegments = [];

            let pathHolder = [
                { 
                    id: 0,
                    startPoint: { x: 519, y: 889 },
                    endPoint: { x: 397, y: 117 },
                    segments: [
                        { index: 0,  p0: { x: 519, y: 889, split: false, distToEnd: 0 }, p1: { x: 668, y: 750, split: false, distToEnd: 0 }, centerPoint: { x: 593.5, y: 819.5 }, length: 203.7694775966214,  startPosition: { x: 519, y: 889 }, endPosition: null               },
                        { index: 1,  p0: { x: 668, y: 750, split: false, distToEnd: 0 }, p1: { x: 671, y: 570, split: true,  distToEnd: 0 }, centerPoint: { x: 669.5, y: 660 },   length: 180.02499826412998, startPosition: null,               endPosition: null               },
                        { index: 2,  p0: { x: 671, y: 570, split: true,  distToEnd: 0 }, p1: { x: 774, y: 482, split: true,  distToEnd: 0 }, centerPoint: { x: 722.5, y: 526 },   length: 135.47324459095236, startPosition: null,               endPosition: null               },
                        { index: 3,  p0: { x: 774, y: 482, split: true,  distToEnd: 0 }, p1: { x: 864, y: 403, split: false, distToEnd: 0 }, centerPoint: { x: 819, y: 442.5 },   length: 119.75391434103521, startPosition: null,               endPosition: null               },
                        { index: 4,  p0: { x: 864, y: 403, split: false, distToEnd: 0 }, p1: { x: 862, y: 249, split: false, distToEnd: 0 }, centerPoint: { x: 863, y: 326 },     length: 154.01298646542764, startPosition: null,               endPosition: null               },
                        { index: 5,  p0: { x: 774, y: 482, split: true,  distToEnd: 0 }, p1: { x: 684, y: 407, split: false, distToEnd: 0 }, centerPoint: { x: 729, y: 444.5 },   length: 117.15374513859982, startPosition: null,               endPosition: null               },
                        { index: 6,  p0: { x: 671, y: 570, split: true,  distToEnd: 0 }, p1: { x: 577, y: 492, split: false, distToEnd: 0 }, centerPoint: { x: 624, y: 531 },     length: 122.14745187681976, startPosition: null,               endPosition: null               },
                        { index: 7,  p0: { x: 577, y: 492, split: false, distToEnd: 0 }, p1: { x: 577, y: 272, split: true,  distToEnd: 0 }, centerPoint: { x: 577, y: 382 },     length: 220,                startPosition: null,               endPosition: null               },
                        { index: 8,  p0: { x: 742, y: 118, split: false, distToEnd: 0 }, p1: { x: 577, y: 272, split: true,  distToEnd: 0 }, centerPoint: { x: 659.5, y: 195 },   length: 225.7011298155151,  startPosition: null,               endPosition: null               },
                        { index: 9,  p0: { x: 397, y: 117, split: false, distToEnd: 0 }, p1: { x: 577, y: 272, split: true,  distToEnd: 0 }, centerPoint: { x: 487, y: 194.5 },   length: 237.53947040439405, startPosition: null,               endPosition: { x: 397, y: 117 } },
                        { index: 10, p0: { x: 519, y: 889, split: false, distToEnd: 0 }, p1: { x: 359, y: 734, split: false, distToEnd: 0 }, centerPoint: { x: 439, y: 811.5 },   length: 222.76669409945464, startPosition: null,               endPosition: null               },
                        { index: 11, p0: { x: 359, y: 734, split: false, distToEnd: 0 }, p1: { x: 359, y: 577, split: false, distToEnd: 0 }, centerPoint: { x: 359, y: 655.5 },   length: 157,                startPosition: null,               endPosition: null               },
                        { index: 12, p0: { x: 359, y: 577, split: false, distToEnd: 0 }, p1: { x: 239, y: 493, split: false, distToEnd: 0 }, centerPoint: { x: 299, y: 535 },     length: 146.47866738880444, startPosition: null,               endPosition: null               },
                    ] 
                }
            ];

            if ( DEBUG === true ) {

                rebuildDebugElements();

            }

            //---

            function initGUI() {
            
                const _drawPath = () => {
                
                    editorMode = EDITOR_MODE_ENUM.drawPath;
                
                }
                
                const _setstartPosition = () => {
                
                    editorMode = EDITOR_MODE_ENUM.setstartPosition;
                
                }
                
                const _setendPosition = () => {
                
                    editorMode = EDITOR_MODE_ENUM.setendPosition;
                
                }

                const _getPathSegment = () => {

                    editorMode = EDITOR_MODE_ENUM.getPathSegment;

                }
                
                const _clearAll = () => {

                    currentPathSegment = null;
                    pathSegments = [];
                    pathHolder[ 0 ] = { id: 0, segments: pathSegments };

                    removeDebugElements();
                
                }

                const _sortPath = () => {

                    sortPath( pathHolder[ 0 ] );

                }

                const _logPath = () => {
                
                    //console.log( pathHolder[ 0 ].segments );

                    let output = '';

                    const segments = pathHolder[ 0 ].segments;

                    for ( let i = 0, l = segments.length; i < l; i ++ ) {

                        const segment = segments[ i ];

                        let startPosition = 'null';
                        let endPosition = 'null';

                        if ( segment.startPosition !== null ) {

                            startPosition = '{ x: ' + segment.startPosition.x + ', y: ' + segment.startPosition.y + ' }';

                        }

                        if ( segment.endPosition !== null ) {

                            endPosition = '{ x: ' + segment.endPosition.x + ', y: ' + segment.endPosition.y + ' }';

                        }

                        const line = '{ index: ' + segment.index + ', p0: { x: ' + segment.p0.x + ', y: ' + segment.p0.y + ', split: ' + segment.p0.split + ' }, p1: { x: ' + segment.p1.x + ', y: ' + segment.p1.y + ', split: ' + segment.p1.split + ' }, centerPoint: { x: ' + segment.centerPoint.x + ', y: ' + segment.centerPoint.y + ' }, length: ' + segment.length + ', startPosition: ' + startPosition + ', endPosition: ' + endPosition + ' },';

                        output += line + '\n';


                    }

                    console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );
                    console.log( output );
                    console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );
                
                }

                const _testPath = () => {
                    
                    testPath();
                
                }
                
                const _linkTo = () => {
                
                    window.open( 'https://twitter.com/niklaswebdev', '_blank' );
                
                }
                
                //---
                
                const guiSetting = {
                        
                    'Draw Path': _drawPath,
                    'Set Start Point': _setstartPosition,
                    'Set End Point': _setendPosition,
                    'Sort Path': _sortPath,
                    'Clear All': _clearAll,
                    'Get PathSegment': _getPathSegment,
                    'Log Path': _logPath,
                    'Test Path': _testPath,
                    '@niklaswebdev': _linkTo
                    
                }

                const gui = new dat.GUI();

                const folderEdit = gui.addFolder( 'Edit' );

                folderEdit.open();
                folderEdit.add( guiSetting, 'Draw Path' );
                folderEdit.add( guiSetting, 'Set Start Point' );
                folderEdit.add( guiSetting, 'Set End Point' );
                folderEdit.add( guiSetting, 'Clear All' );

                const folderAnalyze = gui.addFolder( 'Analyze' );

                folderAnalyze.open();
                //folderAnalyze.add( guiSetting, 'Sort Path' );
                folderAnalyze.add( guiSetting, 'Get PathSegment' );
                folderAnalyze.add( guiSetting, 'Log Path' );
                folderAnalyze.add( guiSetting, 'Test Path' );

                const folderContact = gui.addFolder( 'Contact' );

                folderContact.add( guiSetting, '@niklaswebdev' );

                //gui.close();

            }

            //---

            function init() {
                
                canvas.addEventListener( 'mousedown', mouseDownHandler, false );
                //canvas.addEventListener( 'mouseup', mouseUpHandler, false );
                canvas.addEventListener( 'mousemove', mouseMoveHandler, false );

                document.body.appendChild( canvas );

                window.addEventListener( 'resize', onResize, false );

                restart();

            }

            function onResize( event ) {
                
                restart();

            }

            function restart() {

                width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                canvas.width = width;
                canvas.height = height;

                imageData = context.getImageData( 0, 0, width, height );
                data = imageData.data;
                
                //---

                border.right = width;
                border.bottom = height;

                //---
                
                if ( animationFrame !== null ) {
                
                    cancelAnimFrame( animationFrame );
                
                }
                
                animationFrame = requestAnimFrame( render );

            }

            //---








            function getNextPathSegmentsByPoint( point, pathSegments ) {

                const pathSegmentsFound = [];

                //for ( let i = pathSegments.length - 1, l = -1; i > l; i -- ) {
                for ( let i = 0, l = pathSegments.length; i < l; i ++ ) {

                    const pathSegment = pathSegments[ i ];

                    if ( point.x === pathSegment.p0.x && point.y === pathSegment.p0.y ) {

                        pathSegmentsFound.push( pathSegment );
                    
                    } else if ( point.x === pathSegment.p1.x && point.y === pathSegment.p1.y ) {

                        pathSegmentsFound.push( pathSegment );
                    
                    }

                }

                return pathSegmentsFound;

            }

            function getNextPointsByCurrentPointAndNextPathSegments( point, nextPathSegments ) {

                const pointsFound = [];

                for ( let i = 0, l = nextPathSegments.length; i < l; i ++ ) {

                    const nextPathSegment = nextPathSegments[ i ];

                    if ( point.x === nextPathSegment.p0.x && point.y === nextPathSegment.p0.y ) {

                        pointsFound.push( nextPathSegment.p1 );

                    } else if ( point.x === nextPathSegment.p1.x && point.y === nextPathSegment.p1.y ) {

                        pointsFound.push( nextPathSegment.p0 );

                    }

                }

                return pointsFound;

            }

            function testPath() {

                const pathSegments = [ ...pathHolder[ 0 ].segments ];

                const startPoint = pathHolder[ 0 ].startPoint;
                const endPoint = pathHolder[ 0 ].endPoint;

                //---

                const currentPoint = startPoint;

                //---

                const nextPathSegments = getNextPathSegmentsByPoint( currentPoint, pathSegments );

                console.log( nextPathSegments );





                //const nextPathSegment = nextPathSegments[ i ];

                if ( nextPathSegments.length > 0 ) {

                    const nextPoints = getNextPointsByCurrentPointAndNextPathSegments( currentPoint, nextPathSegments );

                    console.log( nextPoints );

                }







                const test = () => {

                    const nextTiles = [];

                    for ( let i = pathSegments.length - 1, l = -1; i > l; i -- ) {

                        const pathSegment = pathSegments[ i ];

                        //if ( pathSegmentCurrent.index !== pathSegment.index ) {

                            if ( pathSegmentCurrent.p1.x === pathSegment.p0.x && pathSegmentCurrent.p1.y === pathSegment.p0.y ) {

                                //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );
                                //_nextPathSegments.push( { segment: pathSegments.sclice( i, 1 )[ 0 ], index: i } );

                                const nPS = pathSegments.splice( i, 1 )[ 0 ];

                                //_nextPathSegments.push( nPS );
                                //pathSegmentsSave.push( nPS );

                                nextTiles.push( nPS );

                            }

                            if ( pathSegmentCurrent.p1.x === pathSegment.p1.x && pathSegmentCurrent.p1.y === pathSegment.p1.y ) {

                                //flipPathSegmentStartEnd( pathSegment );

                                //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                                const nPS = pathSegments.splice( i, 1 )[ 0 ];

                                //_nextPathSegments.push( nPS );
                                //pathSegmentsSave.push( nPS );

                                nextTiles.push( nPS );

                            }

                            if ( pathSegmentCurrent.p0.x === pathSegment.p0.x && pathSegmentCurrent.p0.y === pathSegment.p0.y ) {

                                //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                                const nPS = pathSegments.splice( i, 1 )[ 0 ];

                                //_nextPathSegments.push( nPS );
                                //pathSegmentsSave.push( nPS );

                                nextTiles.push( nPS );

                            }

                            if ( pathSegmentCurrent.p0.x === pathSegment.p1.x && pathSegmentCurrent.p0.y === pathSegment.p1.y ) {

                                //flipPathSegmentStartEnd( pathSegment );

                                //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                                const nPS = pathSegments.splice( i, 1 )[ 0 ];

                                //_nextPathSegments.push( nPS );
                                //pathSegmentsSave.push( nPS );

                                nextTiles.push( nPS );

                            }

                        //}
                        
                    }

                    console.log( nextTiles );

                };

                //test();

            }

            /*
            function testPath() {

                const pathSegments = [ ...pathHolder[ 0 ].segments ];
                const pathSegmentsLookUp = [ ...pathSegments ];

                //---

                const pathes = [];
                const pathesIndex = 0;

                pathes[ pathesIndex ] = { id: pathesIndex, segments: [], totalLength: 0, foundEnd: false }

                //---

                const pathSegmentStart = pathSegments.find( pathSegment => pathSegment.startPosition !== null );
                //const pathStartPosition = pathSegmentStart.startPosition;
                //const pathSegmentStartIndex = pathSegments.findIndex( pathSegment => pathSegment.startPosition !== null );
                //const pathSegmentStart = pathSegments.splice( pathSegmentStartIndex, 1 )[ 0 ];

                const pathSegmentEnd = pathSegments.find( pathSegment => pathSegment.endPosition !== null );
                //const pathEndPosition = pathSegmentEnd.endPosition;

                //---

                recursive( pathSegments, pathSegmentsLookUp, pathes, 0, pathesIndex, 0, pathSegmentStart, [], [], [], pathSegmentStart, pathSegmentEnd );

                //---

                console.log( 'testDone()' );
                //console.log( pathes );

                for ( let i = 0, l = pathes.length; i < l; i ++ ) {

                    const p = pathes[ i ];

                    console.log( 'path ', i.toString(), '(foundEnd: ' + p.foundEnd + ', totalLength: ' + p.totalLength + '):' );

                    for ( let j = 0, m = p.segments.length; j < m; j ++ ) {

                        if ( p.foundEnd === true ) {

                            p.segments[ j ].sorted = true;

                        }

                        console.log( p.segments[ j ].index, ' - ', p.segments[ j ].length );
                        //console.log( p.segments[ j ] );

                    }

                }

            }

            function recursive( pathSegments, pathSegmentsLookUp, pathes, pathCurrentIndex, index, iteration, pathSegmentCurrent, splitpointsIndices, pathSegmentsSave, pathSegmentsSavecurrent, pathSegmentStart, pathSegmentEnd ) {
                console.log('-------------------------recursive-------------------------');
                pathSegmentsSavecurrent.push( pathSegmentCurrent );

                let output_pathSegmentsSavecurrent0 = '[pathSegmentsSavecurrent]: [';
                for ( let i = 0, l = pathSegmentsSavecurrent.length; i < l; i ++ ) {
                    output_pathSegmentsSavecurrent0 += i === l - 1 ? pathSegmentsSavecurrent[ i ].index : pathSegmentsSavecurrent[ i ].index + ', ';
                }
                output_pathSegmentsSavecurrent0 += ']';
                console.log( output_pathSegmentsSavecurrent0 );



                pathes[ index ].segments.push( pathSegmentCurrent );
                pathes[ index ].totalLength += pathSegmentCurrent.length;

                if ( pathSegmentCurrent.p0.x === pathSegmentEnd.endPosition.x && pathSegmentCurrent.p0.y === pathSegmentEnd.endPosition.y ||
                     pathSegmentCurrent.p1.x === pathSegmentEnd.endPosition.x && pathSegmentCurrent.p1.y === pathSegmentEnd.endPosition.y ) {

                    pathes[ index ].foundEnd = true;

                }

                //if ( index === 0 && pathSegmentCurrent.index !==  ) {

                    //console.log( '--> ', pathSegmentCurrent );

                //}

                //iteration++;

                //---

                const _nextPathSegments = [];
                const _pathSegmentsLength = pathSegments.length;

                for ( let i = _pathSegmentsLength - 1, l = -1; i > l; i -- ) {

                    const pathSegment = pathSegments[ i ];

                    if ( pathSegmentCurrent.index !== pathSegment.index ) {

                        if ( pathSegmentCurrent.p1.x === pathSegment.p0.x && pathSegmentCurrent.p1.y === pathSegment.p0.y ) {

                            //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );
                            //_nextPathSegments.push( { segment: pathSegments.sclice( i, 1 )[ 0 ], index: i } );

                            const nPS = pathSegments.splice( i, 1 )[ 0 ];

                            _nextPathSegments.push( nPS );
                            pathSegmentsSave.push( nPS );

                        }

                        if ( pathSegmentCurrent.p1.x === pathSegment.p1.x && pathSegmentCurrent.p1.y === pathSegment.p1.y ) {

                            //flipPathSegmentStartEnd( pathSegment );

                            //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                            const nPS = pathSegments.splice( i, 1 )[ 0 ];

                            _nextPathSegments.push( nPS );
                            pathSegmentsSave.push( nPS );

                        }

                        if ( pathSegmentCurrent.p0.x === pathSegment.p0.x && pathSegmentCurrent.p0.y === pathSegment.p0.y ) {

                            //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                            const nPS = pathSegments.splice( i, 1 )[ 0 ];

                            _nextPathSegments.push( nPS );
                            pathSegmentsSave.push( nPS );

                        }

                        if ( pathSegmentCurrent.p0.x === pathSegment.p1.x && pathSegmentCurrent.p0.y === pathSegment.p1.y ) {

                            //flipPathSegmentStartEnd( pathSegment );

                            //_nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                            const nPS = pathSegments.splice( i, 1 )[ 0 ];

                            _nextPathSegments.push( nPS );
                            pathSegmentsSave.push( nPS );

                        }

                    }
                      
                }

                //---



                //---

                //console.log( _nextPathSegments );

                //---

                if ( _nextPathSegments.length > 1 ) {

                    splitpointsIndices.push( { index: pathCurrentIndex, count: _nextPathSegments.length - 1 } );

                }

                if ( _nextPathSegments.length > 0 ) {

                    //let nextPathSegment = _nextPathSegments[ 0 ];

                    if ( pathCurrentIndex === 0 && _nextPathSegments.length > 1 ) {

                        let followPathSegmentIndex = -1;

                        for ( let i = _nextPathSegments.length - 1, l = -1; i > l; i -- ) {

                            const _nPS = _nextPathSegments[ i ];

                            if ( _nPS.p0 !== null && pathSegmentCurrent.startPosition !== null ) {

                                if ( _nPS.p0.x !== pathSegmentCurrent.startPosition.x && _nPS.p0.y !== pathSegmentCurrent.startPosition.y &&
                                     _nPS.p1.x !== pathSegmentCurrent.startPosition.x && _nPS.p1.y !== pathSegmentCurrent.startPosition.y ) {

                                    followPathSegmentIndex = i;

                                    break;

                                }

                            }

                        }

                        if ( followPathSegmentIndex > -1 ) {

                            nextPathSegment = _nextPathSegments.splice( followPathSegmentIndex, 1 )[ 0 ];

                        } else {

                            nextPathSegment = _nextPathSegments.shift();

                        }

                        //console.log("sdgdfgsdfgsdfgkjdfhb8e7ortzg9eirhwerighidfughreiubfhrt8o7hv8o725h48o7vrt8gg8o7h4w9p8gjsfgilh249p5gjrtp98zu54ohbjrt54p9z");

                        //splitpoints = [ ...splitpoints, ..._nextPathSegments ];

                    } else {

                        nextPathSegment = _nextPathSegments.shift();

                        //splitpoints = [ ...splitpoints, ..._nextPathSegments ];

                    }

                    //splitpoints = [ ...splitpoints, ..._nextPathSegments ];

                    //console.log( 'nextPathSegment ---> ', nextPathSegment );
                    //console.log( 'splitpoints ---> ', splitpoints );
                    //console.log( 'splitpointsIndices ---> ', splitpointsIndices );
                    //console.log( 'pathSegmentsSave ---> ', pathSegmentsSave );

                    
                    // if ( nextPathSegment.p0.x !== pathSegmentStart.p0.x && nextPathSegment.p0.y !== pathSegmentStart.p0.y &&
                    //      nextPathSegment.p1.x !== pathSegmentStart.p1.x && nextPathSegment.p1.y !== pathSegmentStart.p1.y ) {

                    //         console.log( '---> ', pathSegmentCurrent ); 

                    //         pathes[ index ].segments.push( pathSegmentCurrent );

                    //         pathSegmentCurrent.sorted = true;

                    //         //setTimeout(function(){ alert("Hello"); }, 3000);

                    // }


                    pathCurrentIndex++;

                    //setTimeout( () => {
                        
                        recursive( pathSegments, pathSegmentsLookUp, pathes, pathCurrentIndex, index, iteration, nextPathSegment, splitpointsIndices, pathSegmentsSave, pathSegmentsSavecurrent, pathSegmentStart, pathSegmentEnd )
                    
                    //}, 250 );
                    



                    
                    // if ( pathSegmentCurrent.startPosition !== null ) {

                    //     //if ( pathSegmentCurrent.startPosition.x !== nextPathSegment.p0.x && pathSegmentCurrent.startPosition.y !== nextPathSegment.p0.y ) {

                            

                    //     //}

                    // } else {

                    //     pathes[ index ].segments.push( pathSegmentCurrent );

                    // }
                    

                    //recursive(  );

                } else {
                    console.log( '-----------------------------------------------------------------------------------------------------' );
                    //console.log( '//---> ', pathSegmentsSavecurrent );

                    let output_pathSegmentsSavecurrent = '[pathSegmentsSavecurrent]: [';
                    for ( let i = 0, l = pathSegmentsSavecurrent.length; i < l; i ++ ) {
                        output_pathSegmentsSavecurrent += i === l - 1 ? pathSegmentsSavecurrent[ i ].index : pathSegmentsSavecurrent[ i ].index + ', ';
                    }
                    output_pathSegmentsSavecurrent += ']';
                    console.log( output_pathSegmentsSavecurrent );
                    //console.log( '//---> ', pathSegmentsSave );
                    //console.log( '//---> ', pathSegments );
                    //if ( splitpoints.length > 0 ) {

                    let deadEndPathSegments = [];

                    //const deadEndPathSegments = pathSegmentsSavecurrent.splice( 0, splitpointsIndices[ splitpointsIndices.length - 1 ].index + 1 );



                    // Wenn es Duplikate gibt, dann gibt es eine Wiederholung, was bedeutet, dass dieser Part übersprungen werden kann.
                    const valueArr = pathSegmentsSavecurrent.map( ( item ) => { return item.index } );
                    const foundDuplicate = valueArr.some( ( item, idx ) => { return valueArr.indexOf( item ) != idx } );

                    console.log( 'foundDuplicate ---->: ', foundDuplicate );





                    
                    if ( splitpointsIndices.length > 0 ) {

                        deadEndPathSegments = pathSegmentsSavecurrent.splice( splitpointsIndices[ splitpointsIndices.length - 1 ].index + 1, pathSegmentsSavecurrent.length );

                    }
                    

                    //console.log( splitpointsIndices[ splitpointsIndices.length - 1 ].index, pathSegmentsSavecurrent.length );
                    //console.log( '//---> ', deadEndPathSegments );
                    //splitpointsIndices.push( { index: pathCurrentIndex, count: _nextPathSegments.length - 1 } );

                    let output_deadEndPathSegments = '[deadEndPathSegments]: [';
                    for ( let i = 0, l = deadEndPathSegments.length; i < l; i ++ ) {
                        output_deadEndPathSegments += i === l - 1 ? deadEndPathSegments[ i ].index : deadEndPathSegments[ i ].index + ', ';
                    }
                    output_deadEndPathSegments += ']';
                    console.log( output_deadEndPathSegments );
                    
                    //das splitpointsIndices scheint nicht korrekt zu sein, bzw. wird nicht korrekt zurückgesetzt.
                    let output_splitpointsIndices = '[splitpointsIndices]: [';
                    for ( let i = 0, l = splitpointsIndices.length; i < l; i ++ ) {
                        output_splitpointsIndices += i === l - 1 ? splitpointsIndices[ i ].index : splitpointsIndices[ i ].index + ', ';
                    }
                    output_splitpointsIndices += ']';
                    console.log( output_splitpointsIndices );

                    
                    // console.log("sdfsdfdsfsdf ---->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KILLER : ", splitpointsIndices[ splitpointsIndices.length - 1 ].count);
                    // splitpointsIndices[ splitpointsIndices.length - 1 ].count--;
                    
                    // if ( splitpointsIndices[ splitpointsIndices.length - 1 ].count === 0 ) {

                    //     splitpointsIndices.pop();

                    // }
                    

                    if ( deadEndPathSegments.length > 0 ) {

                        splitpointsIndices.pop();

                    }

                    for ( let i = 0, l = deadEndPathSegments.length; i < l; i ++ ) {

                        const deadEndPathSegment = deadEndPathSegments[ i ];

                        //pathSegmentsSave.splice( pathSegmentsSave.findIndex( pS => pS.index === deadEndPathSegment.index ), 1 );
                        //pathSegmentsLookUp.splice( pathSegmentsSave.findIndex( pS => pS.index === deadEndPathSegment.index ), 1 );

                        //console.log( 'ÄÄÄÄÄ: ',  );

                        for ( let j = pathSegmentsLookUp.length - 1, m = -1; j > m; j -- ) {

                            const pS = pathSegmentsLookUp[ j ];

                            if ( pS.index === deadEndPathSegment.index ) {

                                pathSegmentsLookUp.splice( j, 1 );

                            }

                        }

                    }

                    let output_pathSegmentsSave = '[pathSegmentsSave]: [';
                    for ( let i = 0, l = pathSegmentsSave.length; i < l; i ++ ) {
                        output_pathSegmentsSave += i === l - 1 ? pathSegmentsSave[ i ].index : pathSegmentsSave[ i ].index + ', ';
                    }
                    output_pathSegmentsSave += ']';
                    console.log( output_pathSegmentsSave );

                    //console.log( '//---> ', pathSegmentsSave );

                    pathSegments = [ ...pathSegmentsLookUp ];
                    //console.log( '//---> ', pathSegmentsLookUp );

                    let output_pathSegments = '[pathSegments]: [';
                    for ( let i = 0, l = pathSegments.length; i < l; i ++ ) {
                        output_pathSegments += i === l - 1 ? pathSegments[ i ].index : pathSegments[ i ].index + ', ';
                    }
                    output_pathSegments += ']';
                    console.log( output_pathSegments );

                    let output_pathSegmentsLookUp = '[pathSegmentsLookUp]: [';
                    for ( let i = 0, l = pathSegmentsLookUp.length; i < l; i ++ ) {
                        output_pathSegmentsLookUp += i === l - 1 ? pathSegmentsLookUp[ i ].index : pathSegmentsLookUp[ i ].index + ', ';
                    }
                    output_pathSegmentsLookUp += ']';
                    console.log( output_pathSegmentsLookUp );


                    // if ( splitpointsIndices.length === 1 ) {

                    //     if ( splitpointsIndices[ 0 ].index === 0 ) {

                    //         console.log('---> CUT <---');

                    //         //index--;

                    //     }

                    // }


                    pathSegmentsSave = [];
                    pathSegmentsSavecurrent = [];
                    splitpointsIndices = [];
                    //splitpoints = [];

                    nextPathSegment = pathSegments[ 0 ];

                    

                    pathCurrentIndex = 0;




                    if ( foundDuplicate === true ) {

                        pathes[ index ] = { id: index, segments: [], totalLength: 0, foundEnd: false };

                    } else {

                        index++;

                        pathes[ index ] = { id: index, segments: [], totalLength: 0, foundEnd: false };

                    }

                    // index++;

                    // pathes[ index ] = { id: index, segments: [], totalLength: 0, foundEnd: false };

                    //splitpointsIndices

                    // if ( foundDuplicate === false && pathSegments.length > 3 ) {

                    //     recursive( pathSegments, pathSegmentsLookUp, pathes, pathCurrentIndex, index, iteration, nextPathSegment, splitpointsIndices, pathSegmentsSave, pathSegmentsSavecurrent, pathSegmentStart, pathSegmentEnd )
                    
                    // }

                    iteration++;

                    if ( iteration < 11 ) 
                        recursive( pathSegments, pathSegmentsLookUp, pathes, pathCurrentIndex, index, iteration, nextPathSegment, splitpointsIndices, pathSegmentsSave, pathSegmentsSavecurrent, pathSegmentStart, pathSegmentEnd )
                    


                }




                
            }
            */

            /*
            function testPath() {

                const pathSegments = [ ...pathHolder[ 0 ].segments ];

                console.log( 'testPath()' );

                //---

                for ( let i = 0, l = pathSegments.length; i < l; i ++ ) {

                    const pathSegment = pathSegments[ i ];

                    pathSegment.sorted = false;

                }

                //---

                const pathes = [];
                const pathesIndex = 0;

                pathes[ pathesIndex ] = { id: pathesIndex, segments: [], totalLength: 0, foundEnd: false }

                //---

                const pathSegmentStartIndex = pathSegments.findIndex( pathSegment => pathSegment.startPosition !== null );
                const pathSegmentStart = pathSegments.splice( pathSegmentStartIndex, 1 )[ 0 ];

                //---

                recursive( pathSegments, [ ...pathSegments ], pathes, pathesIndex, 0, pathSegmentStart, [], [ pathSegmentStart ], true );

                //---

                console.log( 'testDone()' );
                //console.log( pathes );

                for ( let i = 0, l = pathes.length; i < l; i ++ ) {

                    const p = pathes[ i ];

                    console.log( 'path ', i.toString(), '(foundEnd: ' + p.foundEnd + ', totalLength: ' + p.totalLength + '):' );

                    for ( let j = 0, m = p.segments.length; j < m; j ++ ) {

                        if ( p.foundEnd === true ) {

                            p.segments[ j ].sorted = true;

                        }

                        console.log( p.segments[ j ].index, ' - ', p.segments[ j ].length );
                        //console.log( p.segments[ j ] );

                    }

                }

            }

            function recursive( pathSegments, pathSegmentsLookUp, pathes, index, iteration, pathSegmentCurrent, splitpoints, pathSegmentsSave, resume = true ) {

                console.log( 'current: ', pathSegmentCurrent.index );

                pathes[ index ].segments.push( pathSegmentCurrent );
                pathes[ index ].totalLength += pathSegmentCurrent.length;

                iteration++;

                pathSegmentsSave.push( pathSegmentCurrent );

                //console.log( pathes[ index ].segments );

                if ( resume === false ) {
                //if ( pathSegments.length === 0 ) {

                    console.log( 'ENDE: ', pathSegments.length );

                    pathes[ index ].foundEnd = true;

                    return;

                }

                const _nextPathSegments = [];
                const _pathSegmentsLength = pathSegments.length;

                //const testi = [ ...pathSegments ];

                for ( let i = _pathSegmentsLength - 1, l = -1; i > l; i -- ) {

                    const pathSegment = pathSegments[ i ];
                    
                    if ( pathSegmentCurrent.p1.x === pathSegment.p0.x && pathSegmentCurrent.p1.y === pathSegment.p0.y ) {

                        _nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                    }

                    if ( pathSegmentCurrent.p1.x === pathSegment.p1.x && pathSegmentCurrent.p1.y === pathSegment.p1.y ) {

                        flipPathSegmentStartEnd( pathSegment );

                        _nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                    }
                    
                    // if ( pathSegmentCurrent.p0.x === pathSegment.p0.x && pathSegmentCurrent.p0.y === pathSegment.p0.y ) {

                    //     _nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                    // }

                    // if ( pathSegmentCurrent.p0.x === pathSegment.p1.x && pathSegmentCurrent.p0.y === pathSegment.p1.y ) {

                    //     flipPathSegmentStartEnd( pathSegment );

                    //     _nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                    // }
                    
                    
                }

                // if ( pathSegmentCurrent.p0.split === true && iteration === 1 ) {

                //     _nextPathSegments.push( pathSegmentCurrent );

                // }

                console.log( pathes[ index ].id , ' -|- ', iteration, '--->> ', _nextPathSegments.length );
                
                //if ( _nextPathSegments.length === 0 ) {



                //}
                

                //

                if ( _nextPathSegments.length > 0 ) {

                    const nextPathSegment = _nextPathSegments[ 0 ];

                    //pathSegmentsSave.push( nextPathSegment );

                    if ( _nextPathSegments.length > 1 ) {

                        //pathSegmentsSave = [];
                        //pathSegmentsSave.push( nextPathSegment );

                        for ( let i = 1, l = _nextPathSegments.length; i < l; i ++ ) {

                            splitpoints.push( _nextPathSegments[ i ] );
                            
                            // const nPS = _nextPathSegments[ i ];

                            // const nextPathSegmentCopy = {};

                            // nextPathSegmentCopy.index = nPS.index;
                            // nextPathSegmentCopy.p0 = nPS.p0;
                            // nextPathSegmentCopy.p1 = nPS.p1;
                            // nextPathSegmentCopy.centerPoint = nPS.centerPoint;
                            // nextPathSegmentCopy.length = nPS.length;
                            // nextPathSegmentCopy.startPosition = nPS.startPosition;
                            // nextPathSegmentCopy.endPosition = nPS.endPosition;

                            // splitpoints.push( nextPathSegmentCopy );

                        }

                    } 
                    
                    // if ( _nextPathSegments.length === 0 ) {

                    //     if ( splitpoints.length > 0 ) {

                    //         pathSegmentsSave = [];
                    //         pathSegmentsSave.push( nextPathSegment );
                    //         console.log("DLRGDLRGDLRGDLRGDLRG", pathSegmentsSave);

                    //     }

                    // }

                    recursive( pathSegments, pathSegmentsLookUp, pathes, index + 0, iteration, nextPathSegment, splitpoints, pathSegmentsSave, true );

                    // for ( let i = 0, l = _nextPathSegments.length; i < l; i ++ ) {

                    //     const nextPathSegment = _nextPathSegments[ i ];

                    //     if ( i > 0 ) {

                    //         pathes[ index + i ] = { id: index + i, segments: [ ...pathes[ index ].segments ].splice( 0, iteration ), totalLength: pathes[ index ].totalLength, foundEnd: false };
                    //         //pathSegments = [ ...pathSegmentsLookUp ];
                    //         console.log("--------------------->>> ", nextPathSegment.index);

                    //     }
                    //     //console.log("///---------------->>> ", nextPathSegment.index);
                    //     if ( nextPathSegment.p1.split === true ) {
                    //         //console.log("--------------------->>> ", nextPathSegment.index);
                    //         //console.log("-------------------------------------------------");

                    //         //pathSegments = [ ...pathSegmentsLookUp ].splice( iteration, pathSegmentsLookUp.length );
                    //         //pathSegments = [ ...pathSegmentsLookUp ].splice( 0, iteration );
                    //         //pathSegments.push( nextPathSegment );

                    //     }

                    //     if ( nextPathSegment.endPosition === null ) {

                    //         recursive( pathSegments, pathSegmentsLookUp, pathes, index + i, iteration, nextPathSegment, splitpoints, true );

                    //     } else {

                    //         //pathSegments = testi;
                    //         //pathSegments.push( pathSegmentCurrent );

                    //         recursive( pathSegments, pathSegmentsLookUp, pathes, index + i, iteration, nextPathSegment, splitpoints, false );

                    //     }

                    // }

                } else {

                    // if ( _nextPathSegments.length === 0 ) {

                    //     if ( splitpoints.length > 0 ) {

                    //         pathSegmentsSave = [];
                    //         pathSegmentsSave.push( nextPathSegment );
                    //         console.log("DLRGDLRGDLRGDLRGDLRG", pathSegmentsSave);

                    //     }

                    // }

                    if ( splitpoints.length > 0 ) {

                        console.log( 'splitpoints.length: ', splitpoints.length );

                        const splitpoint = splitpoints.shift();

                        //pathSegmentsSave.push( splitpoint );

                        console.log( 'splitpoint: ', splitpoint );
                        

                        //pathSegmentsSave

                        let restoredPathSegments = null;

                        if ( pathSegmentsSave.length > 0 ) {

                            console.log("___________________________________________________SDFSDFSDFDSFSDFSDF ", pathSegmentsSave);

                            restoredPathSegments = [ ...pathSegments, ...pathSegmentsSave.splice( 0, pathSegmentsSave.length - iteration ) ];

                        } else {

                            restoredPathSegments = [ ...pathSegments ];

                        }

                        pathSegmentsSave = [];

                        recursive( restoredPathSegments, pathSegmentsLookUp, pathes, index + 0, iteration, splitpoint, splitpoints, pathSegmentsSave, true );

                    }

                }

            }
            */

            










            /*
            function testPath() {

                const pathSegments = [ ...pathHolder[ 0 ].segments ];

                console.log( 'testPath()' );

                //---

                for ( let i = 0, l = pathSegments.length; i < l; i ++ ) {

                    const pathSegment = pathSegments[ i ];

                    pathSegment.sorted = false;

                }

                //---

                const pathes = [];
                const pathesIndex = 0;

                pathes[ pathesIndex ] = { id: pathesIndex, segments: [], totalLength: 0, foundEnd: false }

                //---

                const pathSegmentStartIndex = pathSegments.findIndex( pathSegment => pathSegment.startPosition !== null );
                const pathSegmentStart = pathSegments.splice( pathSegmentStartIndex, 1 )[ 0 ];

                //---

                recursive( pathSegments, [ ...pathSegments ], pathes, pathesIndex, 0, pathSegmentStart, true );

                //---

                console.log( 'testDone()' );
                //console.log( pathes );

                for ( let i = 0, l = pathes.length; i < l; i ++ ) {

                    const p = pathes[ i ];

                    console.log( 'path ', i.toString(), '(foundEnd: ' + p.foundEnd + ', totalLength: ' + p.totalLength + '):' );

                    for ( let j = 0, m = p.segments.length; j < m; j ++ ) {

                        if ( p.foundEnd === true ) {

                            p.segments[ j ].sorted = true;

                        }

                        console.log( p.segments[ j ].index, ' - ', p.segments[ j ].length );
                        //console.log( p.segments[ j ] );

                    }

                }

            }

            function recursive( pathSegments, pathSegmentsLookUp, pathes, index, iteration, pathSegmentCurrent, resume = true ) {

                pathes[ index ].segments.push( pathSegmentCurrent );
                pathes[ index ].totalLength += pathSegmentCurrent.length;

                iteration++;

                //console.log( pathes[ index ].segments );

                if ( resume === false ) {
                //if ( pathSegments.length === 0 ) {

                    console.log( 'ENDE: ', pathSegments.length );

                    pathes[ index ].foundEnd = true;

                    return;

                }

                const _nextPathSegments = [];
                const _pathSegmentsLength = pathSegments.length;

                //const testi = [ ...pathSegments ];

                for ( let i = _pathSegmentsLength - 1, l = -1; i > l; i -- ) {

                    const pathSegment = pathSegments[ i ];
                    
                    if ( pathSegmentCurrent.p1.x === pathSegment.p0.x && pathSegmentCurrent.p1.y === pathSegment.p0.y ) {

                        _nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                    }

                    if ( pathSegmentCurrent.p1.x === pathSegment.p1.x && pathSegmentCurrent.p1.y === pathSegment.p1.y ) {

                        flipPathSegmentStartEnd( pathSegment );

                        _nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                    }

                    if ( pathSegmentCurrent.p0.x === pathSegment.p0.x && pathSegmentCurrent.p0.y === pathSegment.p0.y ) {

                        _nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                    }

                    if ( pathSegmentCurrent.p0.x === pathSegment.p1.x && pathSegmentCurrent.p0.y === pathSegment.p1.y ) {

                        flipPathSegmentStartEnd( pathSegment );

                        _nextPathSegments.push( pathSegments.splice( i, 1 )[ 0 ] );

                    }
                    
                }
                
                // if ( pathSegmentCurrent.p0.split === true && iteration === 1 ) {

                //     _nextPathSegments.push( pathSegmentCurrent );

                // }
                
                console.log( pathes[ index ].id , ' -|- ', iteration, '--->> ', _nextPathSegments.length );

                if ( _nextPathSegments.length > 0 ) {

                    for ( let i = 0, l = _nextPathSegments.length; i < l; i ++ ) {

                        const nextPathSegment = _nextPathSegments[ i ];

                        if ( i > 0 ) {

                            pathes[ index + i ] = { id: index + i, segments: [ ...pathes[ index ].segments ].splice( 0, iteration ), totalLength: pathes[ index ].totalLength, foundEnd: false };
                            //pathSegments = [ ...pathSegmentsLookUp ];
                            console.log("--------------------->>> ", nextPathSegment.index);

                        }
                        //console.log("///---------------->>> ", nextPathSegment.index);
                        if ( nextPathSegment.p1.split === true ) {
                            //console.log("--------------------->>> ", nextPathSegment.index);
                            //console.log("-------------------------------------------------");

                            //pathSegments = [ ...pathSegmentsLookUp ].splice( iteration, pathSegmentsLookUp.length );
                            //pathSegments = [ ...pathSegmentsLookUp ].splice( 0, iteration );
                            //pathSegments.push( nextPathSegment );

                        }

                        if ( nextPathSegment.endPosition === null ) {

                            recursive( pathSegments, pathSegmentsLookUp, pathes, index + i, iteration, nextPathSegment, true );

                        } else {

                            //pathSegments = testi;
                            //pathSegments.push( pathSegmentCurrent );

                            recursive( pathSegments, pathSegmentsLookUp, pathes, index + i, iteration, nextPathSegment, false );

                        }

                    }

                }

            }
            */
            








            //---

            function getPathSegmentPointsWithSamePosition( position ) {

                const path = pathHolder[ 0 ];

                const result = [];

                for ( let i = 0, l = path.segments.length; i < l; i ++ ) {
            
                    const pathSegment = path.segments[ i ];

                    if ( pathSegment.p0.x === position.x && pathSegment.p0.y === position.y ) {

                        result.push( pathSegment.p0 );

                    }

                    if ( pathSegment.p1.x === position.x && pathSegment.p1.y === position.y ) {

                        result.push( pathSegment.p1 );

                    }

                }

                return result;

            }

            function addPathSegment( position ) {

                const path = pathHolder[ 0 ];
                
                if ( currentPathSegment === null ) {
            
                    currentPathSegment = {};
                    currentPathSegment.index = path.segments.length;
                    currentPathSegment.p0 = {};
                    currentPathSegment.p0.x = position.x;
                    currentPathSegment.p0.y = position.y;
                    currentPathSegment.p0.split = false;
                    currentPathSegment.p0.distToEnd = 0;
                    currentPathSegment.p1 = null;
                    currentPathSegment.startPosition = null;
                    currentPathSegment.endPosition = null;
                    currentPathSegment.sorted = false;

                    const pathSegmentPointsWithSamePosition = getPathSegmentPointsWithSamePosition( currentPathSegment.p0 );

                    if ( pathSegmentPointsWithSamePosition.length > 1 ) {

                        pathSegmentPointsWithSamePosition.push( currentPathSegment.p0 );

                        for ( let i = 0, l = pathSegmentPointsWithSamePosition.length; i < l; i++ ) {

                            pathSegmentPointsWithSamePosition[ i ].split = true;

                        }

                    }

                    path.segments.push( currentPathSegment );

                    if ( DEBUG === true ) {

                        addDebugElement( position.x, position.y, position.x.toString() + ', ' + position.y.toString(), 'white', 0, 9, null );

                        addDebugElement( position.x, position.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, currentPathSegment.index );

                    } 
                
                } else {

                    currentPathSegment.p1 = {};
                    currentPathSegment.p1.x = position.x;
                    currentPathSegment.p1.y = position.y;
                    currentPathSegment.p1.split = false;
                    currentPathSegment.p1.distToEnd = 0;
                    currentPathSegment.length = getDistance( currentPathSegment.p0, currentPathSegment.p1 );
                    currentPathSegment.centerPoint = getPathSegmentCenter( currentPathSegment );

                    const pathSegmentPointsWithSamePosition = getPathSegmentPointsWithSamePosition( currentPathSegment.p1 );

                    if ( pathSegmentPointsWithSamePosition.length > 2 ) {

                        pathSegmentPointsWithSamePosition.push( currentPathSegment.p1 );

                        for ( let i = 0, l = pathSegmentPointsWithSamePosition.length; i < l; i++ ) {

                            pathSegmentPointsWithSamePosition[ i ].split = true;

                        }

                    }

                    if ( DEBUG === true ) {

                        addDebugElement( position.x, position.y, position.x.toString() + ', ' + position.y.toString(), 'white', 0, 9, null );
                        addDebugElement( currentPathSegment.centerPoint.x, currentPathSegment.centerPoint.y, currentPathSegment.index.toString(), 'black', -3, -5, null );

                        addDebugElement( position.x, position.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, currentPathSegment.index );

                    } 

                    currentPathSegment = null;

                    //---

                    //sortPath( path );
                
                }

            }

            //---
            /*
            function sortPath( path ) {

                //console.log( 'sortPath()' );

                const pathSegmentsSorted = [];
                const pathSegments = path.segments;

                //console.log( pathSegments );

                //---
                
                const pathSegmentStartIndex = pathSegments.findIndex( pathSegment => pathSegment.startPosition !== null );
                const pathSegmentStart = pathSegments.splice( pathSegmentStartIndex, 1 )[ 0 ];

                const pathSegmentEndIndex = pathSegments.findIndex( pathSegment => pathSegment.endPosition !== null );
                const pathSegmentEnd = pathSegments.splice( pathSegmentEndIndex, 1 )[ 0 ];

                //console.log( pathSegmentStartIndex, pathSegmentEndIndex );
                //console.log( pathSegmentStart, pathSegmentEnd );

                //---

                pathSegmentsSorted.push( pathSegmentStart );

                //---

                let _currentPathSegment = pathSegmentStart;
                let _nextPathSegment = null;
                let _pathSegmentsLength = path.segments.length;

                for ( let j = 0; j < _pathSegmentsLength; j++ ) {

                    for ( let i = path.segments.length - 1, l = -1; i > l; i -- ) {

                        const pathSegment = path.segments[ i ];

                        if ( _currentPathSegment.p1.x === pathSegment.p0.x && _currentPathSegment.p1.y === pathSegment.p0.y ) {

                            _nextPathSegment = path.segments.splice( i, 1 )[ 0 ];

                        }

                        if ( _currentPathSegment.p1.x === pathSegment.p1.x && _currentPathSegment.p1.y === pathSegment.p1.y ) {

                            flipPathSegmentStartEnd( pathSegment );

                            _nextPathSegment = path.segments.splice( i, 1 )[ 0 ];

                        }

                    }

                    pathSegmentsSorted.push( _nextPathSegment );

                    _currentPathSegment = _nextPathSegment;

                }

                //---

                pathSegmentsSorted.push( pathSegmentEnd );

                //---

                for ( let i = 0, l = pathSegmentsSorted.length; i < l; i ++ ) {

                    const pathSegment = pathSegmentsSorted[ i ];

                    pathSegment.sorted = true;
                    pathSegment.index = i;

                }

                //---

                path.segments = [ ...pathSegmentsSorted ];

                //---

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

                //console.log( path.segments );
                //console.log( pathSegmentsSorted );
                //console.log( pathHolder[ 0 ].segments );

                //console.log( 'sortPath() done' );

            }
            */
            //---

            /*
            function flipPathSegmentStartEnd( pathSegment ) {

                const p0Temp = { x: pathSegment.p0.x, y: pathSegment.p0.y, split: pathSegment.p0.split };
                const p1Temp = { x: pathSegment.p1.x, y: pathSegment.p1.y, split: pathSegment.p0.split };

                pathSegment.p0.x = p1Temp.x;
                pathSegment.p0.y = p1Temp.y;
                pathSegment.p0.split = p1Temp.split;

                pathSegment.p1.x = p0Temp.x;
                pathSegment.p1.y = p0Temp.y;
                pathSegment.p1.split = p0Temp.split;

            }
            */

            //---

            function removeStartPositionToPathSegment() {

                const path = pathHolder[ 0 ];

                const pathSegmentsStart = path.segments.filter( pathSegment => pathSegment.startPosition !== null );

                if ( pathSegmentsStart.length > 0 ) {

                    for ( let i = 0, l = pathSegmentsStart.length; i < l; i ++ ) {

                        const pathSegmentStart = pathSegmentsStart[ i ];

                        pathSegmentStart.startPosition = null;

                    }

                }

            }

            function addStartPositionToPathSegment( position ) {

                removeStartPositionToPathSegment();

                //---

                const path = pathHolder[ 0 ];

                for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                    const pathSegment = path.segments[ i ];

                    if ( pathSegment.p0.x === position.x && pathSegment.p0.y === position.y ) {

                        pathSegment.startPosition = { x: position.x, y: position.y };

                    }

                    if ( pathSegment.p1.x === position.x && pathSegment.p1.y === position.y ) {

                        //flipPathSegmentStartEnd( pathSegment );

                        pathSegment.startPosition = { x: position.x, y: position.y };

                    }

                }

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }

            function removeEndPositionToPathSegment() {

                const path = pathHolder[ 0 ];

                const pathSegmentsEnd = path.segments.filter( pathSegment => pathSegment.endPosition !== null );

                if ( pathSegmentsEnd.length > 0 ) {

                    for ( let i = 0, l = pathSegmentsEnd.length; i < l; i ++ ) {

                        const pathSegmentEnd = pathSegmentsEnd[ i ];

                        pathSegmentEnd.endPosition = null;

                    }

                }

            }

            function addEndPositionToPathSegment( position ) {

                removeEndPositionToPathSegment();

                //---

                const path = pathHolder[ 0 ];

                for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                    const pathSegment = path.segments[ i ];

                    if ( pathSegment.p0.x === position.x && pathSegment.p0.y === position.y ) {

                        pathSegment.endPosition = { x: position.x, y: position.y };

                    }

                    if ( pathSegment.p1.x === position.x && pathSegment.p1.y === position.y ) {

                        //flipPathSegmentStartEnd( pathSegment );

                        pathSegment.endPosition = { x: position.x, y: position.y };

                    }

                }

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }










            //---

            function rebuildDebugElements() {

                removeDebugElements();

                //---

                const path = pathHolder[ 0 ];

                path.segments.forEach( ( pathSegment, index ) => {

                    if ( index < path.segments.length - 1 ) {

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, pathSegment.p0.x.toString() + ', ' + pathSegment.p0.y.toString(), 'white', 0, 9, null );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, pathSegment.p1.x.toString() + ', ' + pathSegment.p1.y.toString(), 'white', 0, 9, null );

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );

                    } else {

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, pathSegment.p0.x.toString() + ', ' + pathSegment.p0.y.toString(), 'white', 0, 9, null );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, pathSegment.p1.x.toString() + ', ' + pathSegment.p1.y.toString(), 'white', 0, 9, null );

                        addDebugElement( pathSegment.p0.x, pathSegment.p0.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );
                        addDebugElement( pathSegment.p1.x, pathSegment.p1.y, 'G:999<br/>H:999<br/>F:999', 'white', -40, -40, pathSegment.index );

                    }

                    addDebugElement( pathSegment.centerPoint.x, pathSegment.centerPoint.y, pathSegment.index.toString(), 'black', -3, -5, null );

                    if ( pathSegment.startPosition !== null ) {

                        addDebugElement( pathSegment.startPosition.x, pathSegment.startPosition.y, 'START', 'white', -15, -25, null );

                    }

                    if ( pathSegment.endPosition !== null ) {

                        addDebugElement( pathSegment.endPosition.x, pathSegment.endPosition.y, 'END', 'white', -10, -25, null );

                    }

                } );

            }

            function removeDebugElements() {

                debugElements.forEach( ( debugElement, index ) => {

                    document.body.removeChild( debugElement );

                } );

                debugElements = [];

            }

            function addDebugElement( x, y, message, color = 'white', offsetX = 0, offsetY = 0, className = null ) {

                const debugElement = document.createElement( 'div' );

                debugElement.style.position = 'absolute';
                debugElement.style.left = ( x + offsetX ).toString() + 'px';
                debugElement.style.top = ( y + offsetY ).toString() + 'px';
                debugElement.style.color = color;
                debugElement.style.fontSize = '8pt';
                debugElement.style.pointerEvents = 'none';

                if ( className === null ) {

                    debugElement.className = 'debug-' + ( new Date().getTime() + debugElements.length ).toString();

                } else {

                    debugElement.className = 'debug-' + className.toString();

                }

                debugElement.innerHTML = message;

                document.body.appendChild( debugElement );

                debugElements.push( debugElement );

            }

            //---

            function getDistance( p1, p2 ) {

                const a = p1.x - p2.x;
                const b = p1.y - p2.y;

                return Math.sqrt( a * a + b * b );
            
            }

            function getPathSegmentCenter( pathSegment ) {

                const x = ( pathSegment.p0.x + pathSegment.p1.x ) / 2;
                const y = ( pathSegment.p0.y + pathSegment.p1.y ) / 2;
            
                return { x: x, y: y };
            
            }

            function signedDistanceToLine( p, p0X, p0Y, p1X, p1Y ) {

                const p0p1X = p0X - p1X;
                const p0p1Y = p0Y - p1Y;

                const l2 = p0p1X * p0p1X + p0p1Y * p0p1Y;

                const pp0X = p.x - p0X;
                const pp0Y = p.y - p0Y;

                if ( l2 === 0 ) {

                    return pp0X * pp0X + pp0Y * pp0Y;

                }

                const p1p0X = p1X - p0X;
                const p1p0Y = p1Y - p0Y;

                const t = clamp( ( pp0X * p1p0X + pp0Y * p1p0Y ) / l2, 0, 1 );

                const ptX = p0X + t * p1p0X;
                const ptY = p0Y + t * p1p0Y;

                const pX = p.x - ptX;
                const pY = p.y - ptY;

                return Math.sqrt( pX * pX + pY * pY );

            }

            //---

            function clamp( val, min, max ) {

                return Math.min( Math.max( min, val ), max );

            }

            //---






            //---

            function mouseDownHandler( event ) {

                // editorMode = EDITOR_MODE_ENUM.drawPath;

                if ( editorMode === EDITOR_MODE_ENUM.drawPath ) {

                    addPathSegment( mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.setstartPosition ) {

                    addStartPositionToPathSegment( mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.setendPosition ) {

                    addEndPositionToPathSegment( mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.getPathSegment ) {

                    //addEndPositionToPathSegment( mouseCursor.position );

                }

            }

            function mouseUpHandler( event ) {

                //mouseDown = false;
            
                //mousePosEnd = getMousePos( canvas, event );
            
                //endLineSegment( mousePosEnd );

            }

            function mouseMoveHandler( event ) {

                mousePos = getMousePos( canvas, event );

                if ( editorMode === EDITOR_MODE_ENUM.getPathSegment ) {

                    tempPathSegments = [];

                    //---

                    let distanceTotal = Infinity;
                    let indexSave = -1;

                    pathHolder.forEach( ( path, index ) => {
                
                        for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                            const pathSegment = path.segments[ i ];

                            const distanceToPathSegment = signedDistanceToLine( mousePos, pathSegment.p0.x, pathSegment.p0.y, pathSegment.p1.x, pathSegment.p1.y );

                            if ( distanceToPathSegment < distanceTotal ) {

                                distanceTotal = distanceToPathSegment;

                                indexSave = i;

                            }

                        }

                    } );
                    
                    if ( indexSave > -1 && distanceTotal <= SNAP_TO_DISTANCE ) {

                        const pathSegment = pathHolder[ 0 ].segments[ indexSave ];

                        // console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );
                        // console.log( 'PATH ID: ', pathSegment.index );
                        // console.log( 'p0: ', pathSegment.p0 );
                        // console.log( 'p1: ', pathSegment.p1 );
                        // console.log( 'startPosition: ', pathSegment.startPosition );
                        // console.log( 'endPosition: ', pathSegment.endPosition );
                        // console.log( '-------------------------------------------------------------------------------------------------------------------------------\n' );

                        tempPathSegments.push( { type: 'line', p0: { x: pathSegment.p0.x, y: pathSegment.p0.y }, p1: { x: pathSegment.p1.x, y: pathSegment.p1.y } } );
                        tempPathSegments.push( { type: 'circ', position: { x: pathSegment.p0.x, y: pathSegment.p0.y }, diameter: 20, color: { r: 255, g: 0, b: 255, a: 255 }  } );
                        tempPathSegments.push( { type: 'circ', position: { x: pathSegment.p1.x, y: pathSegment.p1.y }, diameter: 20, color: { r: 0, g: 255, b: 255, a: 255 }  } );

                    }

                }

            }

            function getMousePos( canvas, event ) {

                const rect = canvas.getBoundingClientRect();

                return { x: event.clientX - rect.left, y: event.clientY - rect.top };

            }

            //---

            function clearImageData() {

                for ( let i = 0, l = data.length; i < l; i += 4 ) {

                    data[ i ] = 0;
                    data[ i + 1 ] = 0;
                    data[ i + 2 ] = 0;
                    data[ i + 3 ] = 0;

                }

            }

            function setPixel( x, y, r, g, b, a ) {

                const i = ( x + y * imageData.width ) * 4;

                data[ i ] = r;
                data[ i + 1 ] = g;
                data[ i + 2 ] = b;
                data[ i + 3 ] = a;

            }

            //---

            function drawLine( x1, y1, x2, y2, r, g, b, a ) {

                const dx = Math.abs( x2 - x1 );
                const dy = Math.abs( y2 - y1 );

                const sx = ( x1 < x2 ) ? 1 : -1;
                const sy = ( y1 < y2 ) ? 1 : -1;

                let err = dx - dy;

                let lx = x1;
                let ly = y1;    

                while ( true ) {

                    if ( lx > 0 && lx < width && ly > 0 && ly < height ) {

                        setPixel( lx, ly, r, g, b, a );

                    }

                    if ( ( lx === x2 ) && ( ly === y2 ) ) {
                    
                        break;
                    
                    }

                    const e2 = 2 * err;

                    if ( e2 > -dx ) { 

                        err -= dy; 
                        lx += sx; 

                    }

                    if ( e2 < dy ) { 

                        err += dx; 
                        ly += sy; 

                    }

                }

            }

            function drawCircle( vector, radius, r, g, b, a ) {
                
                const radius2 = radius * radius;

                if ( radius === 1 ) {

                    if ( vector.x > border.left && vector.x < border.right && vector.y > border.top && vector.y < border.bottom ) {

                        setPixel( vector.x2d | 0, vector.y2d | 0, r, g, b, a );

                    }

                    return;

                }
                
                if ( vector.x + radius < border.left || vector.x - radius > border.right || vector.y + radius < border.top || vector.y - radius > border.bottom ) {

                    return;
                
                }

                for ( let tx = -radius; tx < radius; tx ++ ) {

                    for ( let ty = -radius; ty < radius; ty ++ ) {

                        if ( tx * tx + ty * ty <= radius2 ) {
                        
                            const x2d = vector.x + tx;
                            const y2d = vector.y + ty;

                            if ( x2d > border.left && x2d < border.right && y2d > border.top && y2d < border.bottom ) {

                                setPixel( x2d | 0, y2d | 0, r, g, b, a  );

                            }

                        }

                    }

                }

            }

            function drawCircleOutline( vector, radius, r, g, b, a, step = 0.05 ) {

                if ( radius === 1 ) {

                    if ( vector.x > border.left && vector.x < border.right && vector.y > border.top && vector.y < border.bottom ) {

                        setPixel( vector.x2d | 0, vector.y2d | 0, r, g, b, a );

                    }

                    return;

                }
                
                if ( vector.x + radius < border.left || vector.x - radius > border.right || vector.y + radius < border.top || vector.y - radius > border.bottom ) {

                    return;
                
                }

                let lx = vector.x + radius * Math.cos( MATHPI2 );
                let ly = vector.y + radius * Math.sin( MATHPI2 );
                
                for ( let theta = 0; theta < MATHPI2 + step; theta += step ) { 

                    const x = vector.x + radius * Math.cos( theta );
                    const y = vector.y + radius * Math.sin( theta );
                    
                    drawLine( lx | 0, ly | 0, x | 0, y | 0, r, g, b, a );
                    
                    lx = x;
                    ly = y;

                }

            }

            /*
            function drawBox( vector, width, height, r, g, b, a ) {

                if ( vector.x + width / 2 < border.left || vector.x - width / 2 > border.right || vector.y + height / 2 < border.top || vector.y - height / 2 > border.bottom ) {

                    return;
                
                }
                
                for ( let y2d = vector.y - height / 2, y2dE = vector.y + height / 2; y2d < y2dE; y2d ++ ) {
                
                    for ( let x2d = vector.x - width / 2, x2dE = vector.x + width / 2; x2d < x2dE; x2d ++ ) {
                    
                        if ( x2d > border.left && x2d < border.right && y2d > border.top && y2d < border.bottom ) {
                        
                            setPixel( x2d | 0, y2d | 0, r, g, b, a );
                        
                        }
                    
                    }

                }

            }

            function drawBoxOutline( vector, width, height, r, g, b, a ) {

                if ( vector.x + width / 2 < border.left || vector.x - width / 2 > border.right || vector.y + height / 2 < border.top || vector.y - height / 2 > border.bottom ) {

                    return;
                
                }

                const topLeftX = vector.x - width / 2;
                const topLeftY = vector.y - height / 2;
                const topRightX = vector.x + width / 2;
                const topRightY = vector.y - height / 2;
                const bottomLeftX = vector.x - width / 2;
                const bottomLeftY = vector.y + height / 2;
                const bottomRightX = vector.x + width / 2;
                const bottomRightY = vector.y + height / 2;
                
                drawLine( topLeftX | 0, topLeftY | 0, topRightX | 0, topRightY | 0, r, g, b, a );
                drawLine( topRightX | 0, topRightY | 0, bottomRightX | 0, bottomRightY | 0, r, g, b, a );
                drawLine( bottomRightX | 0, bottomRightY | 0, bottomLeftX | 0, bottomLeftY | 0, r, g, b, a );
                drawLine( bottomLeftX | 0, bottomLeftY | 0, topLeftX | 0, topLeftY | 0, r, g, b, a );

            }
            */
            //---








            function draw() {

                mouseCursor.position.x = mousePos.x;
                mouseCursor.position.y = mousePos.y;
                mouseCursor.color = { r: 255, g: 255, b: 255, a: 255 };
                
                pathHolder.forEach( ( path, index ) => {
                
                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                        const pathSegment = path.segments[ i ];

                        if ( pathSegment.p0 !== null && pathSegment.p1 !== null ) {

                            const distancep0 = getDistance( mousePos, pathSegment.p0 );
                            const distancep1 = getDistance( mousePos, pathSegment.p1 );

                            if ( distancep0 <= SNAP_TO_DISTANCE ) {

                                mouseCursor.position.x = pathSegment.p0.x;
                                mouseCursor.position.y = pathSegment.p0.y;
                                mouseCursor.color = { r: 0, g: 255, b: 0, a: 255 };
                                
                                //console.log( 'p0: ', pathSegment.p0.x, pathSegment.p0.y, mousePos.x, mousePos.y );

                            } else if ( distancep1 <= SNAP_TO_DISTANCE ) {

                                mouseCursor.position.x = pathSegment.p1.x;
                                mouseCursor.position.y = pathSegment.p1.y;
                                mouseCursor.color = { r: 0, g: 255, b: 0, a: 255 };

                                //console.log( 'p1: ', pathSegment.p1.x, pathSegment.p1.y, mousePos.x, mousePos.y );

                            }

                        }

                    }
            
                    //---

                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {
            
                        const pathSegment = path.segments[ i ];

                        if ( pathSegment.p0 !== null ) {

                            if ( pathSegment.p1 === null && i === l - 1 ) {

                                drawLine( pathSegment.p0.x | 0, pathSegment.p0.y | 0, mouseCursor.position.x | 0, mouseCursor.position.y | 0, 80, 80, 80, 255 );

                            }

                            drawCircle( pathSegment.p0, 3, 255, 0, 0, 255 );

                        }

                        if ( pathSegment.p1 !== null ) {

                            if ( pathSegment.sorted === true ) {
                            
                                drawLine( pathSegment.p0.x | 0, pathSegment.p0.y | 0, pathSegment.p1.x | 0, pathSegment.p1.y | 0, 0, 200, 0, 255 );
                            
                            } else {
                            
                                drawLine( pathSegment.p0.x | 0, pathSegment.p0.y | 0, pathSegment.p1.x | 0, pathSegment.p1.y | 0, 200, 0, 0, 255 );
                            
                            }

                            drawCircle( pathSegment.p1, 3, 255, 0, 0, 255 );

                            drawCircle( pathSegment.centerPoint, 9, 200, 200, 200, 255 );
                            drawCircleOutline( pathSegment.centerPoint, 9, 255, 0, 0, 255 );

                            
                            if ( pathSegment.p0.split === true ) {

                                drawCircleOutline( pathSegment.p0, 9, 255, 0, 0, 255 );

                            }

                            if ( pathSegment.p1.split === true ) {

                                drawCircleOutline( pathSegment.p1, 9, 255, 0, 0, 255 );

                            }
                            
                                    
                            if ( pathSegment.startPosition !== null ) {

                                drawCircle( pathSegment.startPosition, 5, 0, 255, 0, 255 );
                                drawCircleOutline( pathSegment.startPosition, 9, 0, 255, 0, 255 );

                            }

                            if ( pathSegment.endPosition !== null ) {

                                drawCircle( pathSegment.endPosition, 5, 0, 255, 0, 255 );
                                drawCircleOutline( pathSegment.endPosition, 9, 0, 255, 0, 255 );

                            }

                        }
                        /*
                        if ( pathSegment.splitPoints.length > 0 ) {
                        
                            pathSegment.splitPoints.forEach( ( splitPoint, index ) => {
                            
                                drawCircleOutline( splitPoint, 9, 255, 0, 0, 255 );
                            
                            } );
                            
                        }
                        */

                    }
                
                } );
                
                //---

                drawCircleOutline( mouseCursor.position, mouseCursor.diameter, mouseCursor.color.r, mouseCursor.color.g, mouseCursor.color.b, mouseCursor.color.a );

                //---

                //drawBox( rectangle.position, rectangle.dimensions.width, rectangle.dimensions.height, 15, 15, 15, 255 );

                //---

                for ( let i = 0, l = tempPathSegments.length; i < l; i ++ ) {
            
                    const tempPathSegment = tempPathSegments[ i ];

                    if ( tempPathSegment.type === 'line' ) {

                        drawLine( tempPathSegment.p0.x | 0, tempPathSegment.p0.y | 0, tempPathSegment.p1.x | 0, tempPathSegment.p1.y | 0, 0, 200, 0, 255 );

                    } else if ( tempPathSegment.type === 'circ' ) {

                        drawCircleOutline( tempPathSegment.position, tempPathSegment.diameter, tempPathSegment.color.r, tempPathSegment.color.g, tempPathSegment.color.b, tempPathSegment.color.a );

                    }

                    

                }

            }








            //---

            function render( timestamp ) {

                clearImageData();

                //---

                draw();

                //---

                context.putImageData( imageData, 0, 0 );

                //---

                animationFrame = requestAnimFrame( render );

            }

            window.requestAnimFrame = ( function() {

                return  window.requestAnimationFrame       ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame    ||
                        window.msRequestAnimationFrame     ||
                        function( callback ) {
                            window.setTimeout( callback, 1000 / 60 );
                        };

            } )();

            window.cancelAnimFrame = ( function() {

                return  window.cancelAnimationFrame       ||
                        window.mozCancelAnimationFrame;

            } )();

            //---

            init();
            initGUI();

            //---

        } );
        
    </script>

</head>

<body>

    

</body>

</html>