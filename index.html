<!DOCTYPE html>
<html>

<head>

    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TrackTool</title>
    <script src='./js/dat.gui.min.js'></script>

    <style type='text/css'>

        html, body, div {
            margin: 0;
            padding: 0;
            border: 0;
        }

        body {
            min-height: 100vh;
            overflow: hidden;
            background: radial-gradient(#202020, #000000);
        }

    </style>

    <script>

        document.addEventListener( 'DOMContentLoaded', () => {

            //---

            console.clear();
            console.log( 'Track Tool' );

            //---

            const DEBUG = true;
            let debugElements = [];

            const MATHPI2 = Math.PI * 2;

            const SNAP_TO_DISTANCE = 25;

            const EDITOR_MODE_ENUM = Object.freeze( {
                drawPath: 'drawPath', 
                setStartPoint: 'setStartPoint', 
                setSplitPoint: 'setSplitPoint', 
                setEndPoint: 'setEndPoint'
            } );

            let editorMode = EDITOR_MODE_ENUM.drawPath;

            let width = 1024;
            let height = 512;

            const canvas = document.createElement( 'canvas' );
            const context = canvas.getContext( '2d' );

            let animationFrame = null;

            let imageData = null;
            let data = null;

            const border = { left: 1, top: 1, right: width, bottom: height };

            let mouseDown = false;
            let mousePos = { x: 0, y: 0 };
            let mousePosStart = { x: 0, y: 0 };
            let mousePosEnd = { x: 0, y: 0 };
            const mouseCursor = { diameter: 9, color: { r: 255, g: 255, b: 255, a: 255 }, position: { x: 0, y: 0 } };

            let currentPathSegment = null;

            let pathHolder = [

                { 
                    id: 0, 
                    segments: [

                        { index: 0, startPosition: { x: 240, y: 438 }, endPosition: { x: 521, y: 363 }, centerPosition: { x: 380.5, y: 400.5 }, length: 290.8367239534925, startPoint: { x: 240, y: 438 }, splitPoints: [], endPoint: null },
                        { index: 1, startPosition: { x: 521, y: 363 }, endPosition: { x: 980, y: 371 }, centerPosition: { x: 750.5, y: 367 }, length: 459.0697114818184, startPoint: null, splitPoints: [], endPoint: null },
                        { index: 2, startPosition: { x: 980, y: 371 }, endPosition: { x: 1154, y: 219 }, centerPosition: { x: 1067, y: 295 }, length: 231.0411218809327, startPoint: null, splitPoints: [], endPoint: null },
                        { index: 3, startPosition: { x: 1154, y: 219 }, endPosition: { x: 1143, y: 95 }, centerPosition: { x: 1148.5, y: 157 }, length: 124.4869471069156, startPoint: null, splitPoints: [], endPoint: null },
                        { index: 4, startPosition: { x: 1143, y: 95 }, endPosition: { x: 536, y: 97 }, centerPosition: { x: 839.5, y: 96 }, length: 607.0032948839735, startPoint: null, splitPoints: [], endPoint: null },
                        { index: 5, startPosition: { x: 536, y: 97 }, endPosition: { x: 158, y: 162 }, centerPosition: { x: 347, y: 129.5 }, length: 383.54791095767945, startPoint: null, splitPoints: [], endPoint: { x: 158, y: 162 } }

                    ] 
                }

            ];

            if ( DEBUG === true ) {

                rebuildDebugElements();

            }

            //---

            function initGUI() {
            
                const _drawPath = () => {
                
                    editorMode = EDITOR_MODE_ENUM.drawPath;
                
                }
                
                const _setStartPoint = () => {
                
                    editorMode = EDITOR_MODE_ENUM.setStartPoint;
                
                }
                
                const _setSplitPoint = () => {
                
                    editorMode = EDITOR_MODE_ENUM.setSplitPoint;
                
                }
                
                const _setEndPoint = () => {
                
                    editorMode = EDITOR_MODE_ENUM.setEndPoint;
                
                }
                
                const _sortPath = () => {

                    sortPath( pathHolder[ 0 ] );
                
                }
                
                const _clearAll = () => {

                    currentPathSegment = null;
                    pathSegments = [];
                    pathHolder[ 0 ] = { id: 0, segments: pathSegments };

                    removeDebugElements();
                
                }

                const _logPath = () => {
                
                    console.log( pathHolder[ 0 ].segments );
                
                }
                
                const _linkTo = () => {
                
                    window.open( 'https://twitter.com/niklaswebdev', '_blank' );
                
                }
                
                //---
                
                const guiSetting = {
                        
                    'Draw Path': _drawPath,
                    'Set Start Point': _setStartPoint,
                    'Set Split Point': _setSplitPoint,
                    'Set End Point': _setEndPoint,
                    'Sort Path': _sortPath,
                    'Clear All': _clearAll,
                    'Log Path': _logPath,
                    '@niklaswebdev': _linkTo
                    
                }

                const gui = new dat.GUI();
                
                //gui.close();
                gui.add( guiSetting, 'Draw Path' );
                gui.add( guiSetting, 'Set Start Point' );
                //gui.add( guiSetting, 'Set Split Point' );
                gui.add( guiSetting, 'Set End Point' );
                gui.add( guiSetting, 'Sort Path' );
                gui.add( guiSetting, 'Clear All' );
                gui.add( guiSetting, 'Log Path' );
                gui.add( guiSetting, '@niklaswebdev' );

            }

            //---

            function init() {
                
                canvas.addEventListener( 'mousedown', mouseDownHandler, false );
                //canvas.addEventListener( 'mouseup', mouseUpHandler, false );
                canvas.addEventListener( 'mousemove', mouseMoveHandler, false );

                document.body.appendChild( canvas );

                window.addEventListener( 'resize', onResize, false );

                restart();

            }

            function onResize( event ) {
                
                restart();

            }

            function restart() {

                width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

                canvas.width = width;
                canvas.height = height;

                imageData = context.getImageData( 0, 0, width, height );
                data = imageData.data;
                
                //---

                border.right = width;
                border.bottom = height;

                //---
                
                if ( animationFrame !== null ) {
                
                    cancelAnimFrame( animationFrame );
                
                }
                
                animationFrame = requestAnimFrame( render );

            }

            //---

            function addPathSegment( position ) {

                const path = pathHolder[ 0 ];
                /*
                const _checkIfPointAlreadyExists = ( comparePosition, index ) => {

                    let result = false;

                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {
            
                        const pathSegment = path.segments[ i ];

                        //console.log( pathSegment );
                        
                        //if ( pathSegment !== index ) {

                            if ( pathSegment.startPosition.x === comparePosition.x && pathSegment.startPosition.y === comparePosition.y ) {
                        
                                //result = true;
                                pathSegment.sorted = true;
                                pathSegment.splitPoints.push( { x: pathSegment.startPosition.x, y: pathSegment.startPosition.y } );

                                //console.log("FOUND S: ", pathSegment.startPosition.x, ' ',pathSegment.startPosition.y );
                            
                            }
                            
                            if ( pathSegment.endPosition.x === comparePosition.x && pathSegment.endPosition.y === comparePosition.y ) {
                            
                                //result = true;
                                pathSegment.sorted = true;
                                //pathSegment.splitPoints.push( { x: comparePosition.x, y: comparePosition.y } );
                                pathSegment.splitPoints.push( { x: pathSegment.endPosition.x, y: pathSegment.endPosition.y } );

                                //console.log("FOUND E: ", pathSegment.endPosition.x, ' ',pathSegment.endPosition.y );
                            
                            }

                        //}

                    }

                    //console.log( '\n' );

                    return result;
                
                }
                */
                if ( currentPathSegment === null ) {
            
                    currentPathSegment = {};
                    currentPathSegment.index = path.segments.length;
                    currentPathSegment.startPosition = {};
                    currentPathSegment.startPosition.x = position.x;
                    currentPathSegment.startPosition.y = position.y;
                    currentPathSegment.endPosition = null;
                    currentPathSegment.startPoint = null;
                    currentPathSegment.splitPoints = [];
                    currentPathSegment.endPoint = null;
                    currentPathSegment.sorted = false;
                    
                    //if ( _checkIfPointAlreadyExists( currentPathSegment.startPosition, currentPathSegment.index ) === true ) {
                    
                        //currentPathSegment.splitPoints.push( { x: position.x, y: position.y } );
                    
                    //}
                    
                    path.segments.push( currentPathSegment );

                    if ( DEBUG === true ) {

                        addDebugElement( position.x, position.y, position.x.toString() + ', ' + position.y.toString(), 'white', 0, 9 );

                    } 
                
                } else {

                    currentPathSegment.endPosition = {};
                    currentPathSegment.endPosition.x = position.x;
                    currentPathSegment.endPosition.y = position.y;
                    currentPathSegment.length = getDistance( currentPathSegment.startPosition, currentPathSegment.endPosition );
                    currentPathSegment.centerPosition = getPathSegmentCenter( currentPathSegment );
                    
                    //if ( _checkIfPointAlreadyExists( currentPathSegment.endPosition ) === true ) {
                    
                        //currentPathSegment.splitPoints.push( { x: pathSegment.endPosition.x, y: pathSegment.endPosition.y } );
                    
                    //}

                    if ( DEBUG === true ) {

                        addDebugElement( position.x, position.y, position.x.toString() + ', ' + position.y.toString(), 'white', 0, 9 );
                        addDebugElement( currentPathSegment.centerPosition.x, currentPathSegment.centerPosition.y, currentPathSegment.index.toString(), 'black', -3, -5 );

                    } 

                    currentPathSegment = null;

                    //---

                    //sortPath( path );
                
                }

            }

            //---

            function sortPath( path ) {

                //console.log( 'sortPath()' );

                const pathSegmentsSorted = [];
                const pathSegments = path.segments;

                //console.log( pathSegments );

                //---
                
                const pathSegmentStartIndex = pathSegments.findIndex( pathSegment => pathSegment.startPoint !== null );
                const pathSegmentStart = pathSegments.splice( pathSegmentStartIndex, 1 )[ 0 ];

                const pathSegmentEndIndex = pathSegments.findIndex( pathSegment => pathSegment.endPoint !== null );
                const pathSegmentEnd = pathSegments.splice( pathSegmentEndIndex, 1 )[ 0 ];

                //console.log( pathSegmentStartIndex, pathSegmentEndIndex );
                //console.log( pathSegmentStart, pathSegmentEnd );

                //---

                pathSegmentsSorted.push( pathSegmentStart );

                //---

                let _currentPathSegment = pathSegmentStart;
                let _nextPathSegment = null;
                let _pathSegmentsLength = path.segments.length;

                for ( let j = 0; j < _pathSegmentsLength; j++ ) {

                    for ( let i = path.segments.length - 1, l = -1; i > l; i -- ) {

                        const pathSegment = path.segments[ i ];

                        if ( _currentPathSegment.endPosition.x === pathSegment.startPosition.x && _currentPathSegment.endPosition.y === pathSegment.startPosition.y ) {

                            _nextPathSegment = path.segments.splice( i, 1 )[ 0 ];

                        }

                        if ( _currentPathSegment.endPosition.x === pathSegment.endPosition.x && _currentPathSegment.endPosition.y === pathSegment.endPosition.y ) {

                            flipPathSegmentStartEnd( pathSegment );

                            _nextPathSegment = path.segments.splice( i, 1 )[ 0 ];

                        }

                    }

                    pathSegmentsSorted.push( _nextPathSegment );

                    _currentPathSegment = _nextPathSegment;

                }

                //---

                pathSegmentsSorted.push( pathSegmentEnd );

                //---

                for ( let i = 0, l = pathSegmentsSorted.length; i < l; i ++ ) {

                    const pathSegment = pathSegmentsSorted[ i ];

                    pathSegment.sorted = true;
                    pathSegment.index = i;

                }

                //---

                path.segments = [ ...pathSegmentsSorted ];

                //---

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

                //console.log( path.segments );
                //console.log( pathSegmentsSorted );
                //console.log( pathHolder[ 0 ].segments );

                //console.log( 'sortPath() done' );

            }

            //---

            function flipPathSegmentStartEnd( pathSegment ) {

                const startPosTemp = { x: pathSegment.startPosition.x, y: pathSegment.startPosition.y };
                const endPosTemp = { x: pathSegment.endPosition.x, y: pathSegment.endPosition.y };

                pathSegment.startPosition.x = endPosTemp.x;
                pathSegment.startPosition.y = endPosTemp.y;

                pathSegment.endPosition.x = startPosTemp.x;
                pathSegment.endPosition.y = startPosTemp.y;

            }

            //---

            function removeStartPointToPathSegment() {

                const path = pathHolder[ 0 ];

                const pathSegmentStart = path.segments.find( pathSegment => pathSegment.startPoint !== null );

                if ( typeof pathSegmentStart !== 'undefined' ) {

                    pathSegmentStart.startPoint = null;

                }

            }

            function addStartPointToPathSegment( position ) {

                removeStartPointToPathSegment();

                //---

                const path = pathHolder[ 0 ];

                for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                    const pathSegment = path.segments[ i ];

                    if ( pathSegment.startPosition.x === position.x && pathSegment.startPosition.y === position.y ) {

                        pathSegment.startPoint = { x: position.x, y: position.y };

                    }

                    if ( pathSegment.endPosition.x === position.x && pathSegment.endPosition.y === position.y ) {

                        flipPathSegmentStartEnd( pathSegment );

                        pathSegment.startPoint = { x: position.x, y: position.y };

                    }

                }

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }

            function removeEndPointToPathSegment() {

                const path = pathHolder[ 0 ];

                const pathSegmentEnd = path.segments.find( pathSegment => pathSegment.endPoint !== null );

                if ( typeof pathSegmentEnd !== 'undefined' ) {

                    pathSegmentEnd.endPoint = null;

                }

            }

            function addEndPointToPathSegment( position ) {

                removeEndPointToPathSegment();

                //---

                const path = pathHolder[ 0 ];

                for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                    const pathSegment = path.segments[ i ];

                    if ( pathSegment.startPosition.x === position.x && pathSegment.startPosition.y === position.y ) {

                        pathSegment.endPoint = { x: position.x, y: position.y };

                    }

                    if ( pathSegment.endPosition.x === position.x && pathSegment.endPosition.y === position.y ) {

                        flipPathSegmentStartEnd( pathSegment );

                        pathSegment.endPoint = { x: position.x, y: position.y };

                    }

                }

                if ( DEBUG === true ) {

                    rebuildDebugElements();

                }

            }










            //---

            function rebuildDebugElements() {

                removeDebugElements();

                //---

                const path = pathHolder[ 0 ];

                path.segments.forEach( ( pathSegment, index ) => {

                    if ( index < path.segments.length - 1 ) {

                        addDebugElement( pathSegment.startPosition.x, pathSegment.startPosition.y, pathSegment.startPosition.x.toString() + ', ' + pathSegment.startPosition.y.toString(), 'white', 0, 9 );

                    } else {

                        addDebugElement( pathSegment.startPosition.x, pathSegment.startPosition.y, pathSegment.startPosition.x.toString() + ', ' + pathSegment.startPosition.y.toString(), 'white', 0, 9 );
                        addDebugElement( pathSegment.endPosition.x, pathSegment.endPosition.y, pathSegment.endPosition.x.toString() + ', ' + pathSegment.endPosition.y.toString(), 'white', 0, 9 );

                    }

                    addDebugElement( pathSegment.centerPosition.x, pathSegment.centerPosition.y, pathSegment.index.toString(), 'black', -3, -5 );

                    if ( pathSegment.startPoint !== null ) {

                        addDebugElement( pathSegment.startPoint.x, pathSegment.startPoint.y, 'START', 'white', -15, -25 );

                    }

                    if ( pathSegment.endPoint !== null ) {

                        addDebugElement( pathSegment.endPoint.x, pathSegment.endPoint.y, 'END', 'white', -10, -25 );

                    }

                } );

            }

            function removeDebugElements() {

                debugElements.forEach( ( debugElement, index ) => {

                    document.body.removeChild( debugElement );

                } );

                debugElements = [];

            }

            function addDebugElement( x, y, message, color = 'white', offsetX = 0, offsetY = 0 ) {

                const debugElement = document.createElement( 'div' );

                debugElement.style.position = 'absolute';
                debugElement.style.left = ( x + offsetX ).toString() + 'px';
                debugElement.style.top = ( y + offsetY ).toString() + 'px';
                debugElement.style.color = color;
                debugElement.style.fontSize = '8pt';
                debugElement.style.pointerEvents = 'none';

                debugElement.innerHTML = message;

                document.body.appendChild( debugElement );

                debugElements.push( debugElement );

            }

            //---

            function getDistance( p1, p2 ) {

                const a = p1.x - p2.x;
                const b = p1.y - p2.y;

                return Math.sqrt( a * a + b * b );
            
            }

            function getPathSegmentCenter( pathSegment ) {

                const x = ( pathSegment.startPosition.x + pathSegment.endPosition.x ) / 2;
                const y = ( pathSegment.startPosition.y + pathSegment.endPosition.y ) / 2;
            
                return { x: x, y: y };
            
            }

            //---












            //---

            function mouseDownHandler( event ) {

                // editorMode = EDITOR_MODE_ENUM.drawPath;

                if ( editorMode === EDITOR_MODE_ENUM.drawPath ) {

                    addPathSegment( mouseCursor.position );

                } else if ( editorMode === EDITOR_MODE_ENUM.setStartPoint ) {

                    addStartPointToPathSegment( mouseCursor.position );


                } else if ( editorMode === EDITOR_MODE_ENUM.setEndPoint ) {

                    addEndPointToPathSegment( mouseCursor.position );

                }

            }

            function mouseUpHandler( event ) {

                //mouseDown = false;
            
                //mousePosEnd = getMousePos( canvas, event );
            
                //endLineSegment( mousePosEnd );

            }

            function mouseMoveHandler( event ) {

                mousePos = getMousePos( canvas, event );

            }

            function getMousePos( canvas, event ) {

                const rect = canvas.getBoundingClientRect();

                return { x: event.clientX - rect.left, y: event.clientY - rect.top };

            }

            //---

            function clearImageData() {

                for ( let i = 0, l = data.length; i < l; i += 4 ) {

                    data[ i ] = 0;
                    data[ i + 1 ] = 0;
                    data[ i + 2 ] = 0;
                    data[ i + 3 ] = 0;

                }

            }

            function setPixel( x, y, r, g, b, a ) {

                const i = ( x + y * imageData.width ) * 4;

                data[ i ] = r;
                data[ i + 1 ] = g;
                data[ i + 2 ] = b;
                data[ i + 3 ] = a;

            }

            //---

            function drawLine( x1, y1, x2, y2, r, g, b, a ) {

                const dx = Math.abs( x2 - x1 );
                const dy = Math.abs( y2 - y1 );

                const sx = ( x1 < x2 ) ? 1 : -1;
                const sy = ( y1 < y2 ) ? 1 : -1;

                let err = dx - dy;

                let lx = x1;
                let ly = y1;    

                while ( true ) {

                    if ( lx > 0 && lx < width && ly > 0 && ly < height ) {

                        setPixel( lx, ly, r, g, b, a );

                    }

                    if ( ( lx === x2 ) && ( ly === y2 ) ) {
                    
                        break;
                    
                    }

                    const e2 = 2 * err;

                    if ( e2 > -dx ) { 

                        err -= dy; 
                        lx += sx; 

                    }

                    if ( e2 < dy ) { 

                        err += dx; 
                        ly += sy; 

                    }

                }

            }

            function drawCircle( vector, radius, r, g, b, a ) {
                
                const radius2 = radius * radius;

                if ( radius === 1 ) {

                    if ( vector.x > border.left && vector.x < border.right && vector.y > border.top && vector.y < border.bottom ) {

                        setPixel( vector.x2d | 0, vector.y2d | 0, r, g, b, a );

                    }

                    return;

                }
                
                if ( vector.x + radius < border.left || vector.x - radius > border.right || vector.y + radius < border.top || vector.y - radius > border.bottom ) {

                    return;
                
                }

                for ( let tx = -radius; tx < radius; tx ++ ) {

                    for ( let ty = -radius; ty < radius; ty ++ ) {

                        if ( tx * tx + ty * ty <= radius2 ) {
                        
                            const x2d = vector.x + tx;
                            const y2d = vector.y + ty;

                            if ( x2d > border.left && x2d < border.right && y2d > border.top && y2d < border.bottom ) {

                                setPixel( x2d | 0, y2d | 0, r, g, b, a  );

                            }

                        }

                    }

                }

            }

            function drawCircleOutline( vector, radius, r, g, b, a, step = 0.05 ) {

                if ( radius === 1 ) {

                    if ( vector.x > border.left && vector.x < border.right && vector.y > border.top && vector.y < border.bottom ) {

                        setPixel( vector.x2d | 0, vector.y2d | 0, r, g, b, a );

                    }

                    return;

                }
                
                if ( vector.x + radius < border.left || vector.x - radius > border.right || vector.y + radius < border.top || vector.y - radius > border.bottom ) {

                    return;
                
                }

                let lx = vector.x + radius * Math.cos( MATHPI2 );
                let ly = vector.y + radius * Math.sin( MATHPI2 );
                
                for ( let theta = 0; theta < MATHPI2 + step; theta += step ) { 

                    const x = vector.x + radius * Math.cos( theta );
                    const y = vector.y + radius * Math.sin( theta );
                    
                    drawLine( lx | 0, ly | 0, x | 0, y | 0, r, g, b, a );
                    
                    lx = x;
                    ly = y;

                }

            }

            /*
            function drawBox( vector, width, height, r, g, b, a ) {

                if ( vector.x + width / 2 < border.left || vector.x - width / 2 > border.right || vector.y + height / 2 < border.top || vector.y - height / 2 > border.bottom ) {

                    return;
                
                }
                
                for ( let y2d = vector.y - height / 2, y2dE = vector.y + height / 2; y2d < y2dE; y2d ++ ) {
                
                    for ( let x2d = vector.x - width / 2, x2dE = vector.x + width / 2; x2d < x2dE; x2d ++ ) {
                    
                        if ( x2d > border.left && x2d < border.right && y2d > border.top && y2d < border.bottom ) {
                        
                            setPixel( x2d | 0, y2d | 0, r, g, b, a );
                        
                        }
                    
                    }

                }

            }

            function drawBoxOutline( vector, width, height, r, g, b, a ) {

                if ( vector.x + width / 2 < border.left || vector.x - width / 2 > border.right || vector.y + height / 2 < border.top || vector.y - height / 2 > border.bottom ) {

                    return;
                
                }

                const topLeftX = vector.x - width / 2;
                const topLeftY = vector.y - height / 2;
                const topRightX = vector.x + width / 2;
                const topRightY = vector.y - height / 2;
                const bottomLeftX = vector.x - width / 2;
                const bottomLeftY = vector.y + height / 2;
                const bottomRightX = vector.x + width / 2;
                const bottomRightY = vector.y + height / 2;
                
                drawLine( topLeftX | 0, topLeftY | 0, topRightX | 0, topRightY | 0, r, g, b, a );
                drawLine( topRightX | 0, topRightY | 0, bottomRightX | 0, bottomRightY | 0, r, g, b, a );
                drawLine( bottomRightX | 0, bottomRightY | 0, bottomLeftX | 0, bottomLeftY | 0, r, g, b, a );
                drawLine( bottomLeftX | 0, bottomLeftY | 0, topLeftX | 0, topLeftY | 0, r, g, b, a );

            }
            */
            //---








            function draw() {

                mouseCursor.position.x = mousePos.x;
                mouseCursor.position.y = mousePos.y;
                mouseCursor.color = { r: 255, g: 255, b: 255, a: 255 };
                
                pathHolder.forEach( ( path, index ) => {
                
                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {

                        const pathSegment = path.segments[ i ];

                        if ( pathSegment.startPosition !== null && pathSegment.endPosition !== null ) {

                            const distanceStartPosition = getDistance( mousePos, pathSegment.startPosition );
                            const distanceEndPosition = getDistance( mousePos, pathSegment.endPosition );

                            if ( distanceStartPosition <= SNAP_TO_DISTANCE ) {

                                mouseCursor.position.x = pathSegment.startPosition.x;
                                mouseCursor.position.y = pathSegment.startPosition.y;
                                mouseCursor.color = { r: 0, g: 255, b: 0, a: 255 };
                                
                                //console.log( 'startPosition: ', pathSegment.startPosition.x, pathSegment.startPosition.y, mousePos.x, mousePos.y );

                            } else if ( distanceEndPosition <= SNAP_TO_DISTANCE ) {

                                mouseCursor.position.x = pathSegment.endPosition.x;
                                mouseCursor.position.y = pathSegment.endPosition.y;
                                mouseCursor.color = { r: 0, g: 255, b: 0, a: 255 };

                                //console.log( 'endPosition: ', pathSegment.endPosition.x, pathSegment.endPosition.y, mousePos.x, mousePos.y );

                            }

                        }

                    }
            
                    //---

                    for ( let i = 0, l = path.segments.length; i < l; i ++ ) {
            
                        const pathSegment = path.segments[ i ];

                        if ( pathSegment.startPosition !== null ) {

                            if ( pathSegment.endPosition === null && i === l - 1 ) {

                                drawLine( pathSegment.startPosition.x | 0, pathSegment.startPosition.y | 0, mouseCursor.position.x | 0, mouseCursor.position.y | 0, 80, 80, 80, 255 );

                            }

                            drawCircle( pathSegment.startPosition, 3, 255, 0, 0, 255 );

                        }

                        if ( pathSegment.endPosition !== null ) {

                            if ( pathSegment.sorted === true ) {
                            
                                drawLine( pathSegment.startPosition.x | 0, pathSegment.startPosition.y | 0, pathSegment.endPosition.x | 0, pathSegment.endPosition.y | 0, 0, 200, 0, 255 );
                            
                            } else {
                            
                                drawLine( pathSegment.startPosition.x | 0, pathSegment.startPosition.y | 0, pathSegment.endPosition.x | 0, pathSegment.endPosition.y | 0, 200, 0, 0, 255 );
                            
                            }

                            drawCircle( pathSegment.endPosition, 3, 255, 0, 0, 255 );

                            drawCircle( pathSegment.centerPosition, 9, 200, 200, 200, 255 );
                            drawCircleOutline( pathSegment.centerPosition, 9, 255, 0, 0, 255 );
                                    
                            if ( pathSegment.startPoint !== null ) {

                                drawCircle( pathSegment.startPoint, 5, 0, 255, 0, 255 );
                                drawCircleOutline( pathSegment.startPoint, 9, 0, 255, 0, 255 );

                            }

                            if ( pathSegment.endPoint !== null ) {

                                drawCircle( pathSegment.endPoint, 5, 0, 255, 0, 255 );
                                drawCircleOutline( pathSegment.endPoint, 9, 0, 255, 0, 255 );

                            }

                        }
                    
                        if ( pathSegment.splitPoints.length > 0 ) {
                        
                            pathSegment.splitPoints.forEach( ( splitPoint, index ) => {
                            
                                drawCircleOutline( splitPoint, 9, 255, 0, 0, 255 );
                            
                            } );
                            
                        }

                    }
                
                } );
                
                //---

                drawCircleOutline( mouseCursor.position, mouseCursor.diameter, mouseCursor.color.r, mouseCursor.color.g, mouseCursor.color.b, mouseCursor.color.a );

                //---

                //drawBox( rectangle.position, rectangle.dimensions.width, rectangle.dimensions.height, 15, 15, 15, 255 );

            }








            //---

            function render( timestamp ) {

                clearImageData();

                //---

                draw();

                //---

                context.putImageData( imageData, 0, 0 );

                //---

                animationFrame = requestAnimFrame( render );

            }

            window.requestAnimFrame = ( function() {

                return  window.requestAnimationFrame       ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame    ||
                        window.msRequestAnimationFrame     ||
                        function( callback ) {
                            window.setTimeout( callback, 1000 / 60 );
                        };

            } )();

            window.cancelAnimFrame = ( function() {

                return  window.cancelAnimationFrame       ||
                        window.mozCancelAnimationFrame;

            } )();

            //---

            init();
            initGUI();

            //---

        } );
        
    </script>

</head>

<body>

    

</body>

</html>